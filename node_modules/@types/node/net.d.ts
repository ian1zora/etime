/**
 * > Stability: 2 - Stable
 *
 * The `node:net` module provides an asynchronous network API for creating stream-based
 * TCP or `IPC` servers ({@link createServer}) and clients
 * ({@link createConnection}).
 *
 * It can be accessed using:
 *
 * ```js
 * import net from 'node:net';
 * ```
 * @see [source](https://github.com/nodejs/node/blob/v24.x/lib/net.js)
 */
declare module "net" {
    import { NonSharedBuffer } from "node:buffer";
    import * as stream from "node:stream";
    import { Abortable, EventEmitter } from "node:events";
    import * as dns from "node:dns";
    type LookupFunction = (
        hostname: string,
        options: dns.LookupOptions,
        callback: (err: NodeJS.ErrnoException | null, address: string | dns.LookupAddress[], family?: number) => void,
    ) => void;
    interface AddressInfo {
        address: string;
        family: string;
        port: number;
    }
    interface SocketConstructorOpts {
        fd?: number | undefined;
        allowHalfOpen?: boolean | undefined;
        onread?: OnReadOpts | undefined;
        readable?: boolean | undefined;
        writable?: boolean | undefined;
        signal?: AbortSignal | undefined;
    }
    interface OnReadOpts {
        buffer: Uint8Array | (() => Uint8Array);
        /**
         * This function is called for every chunk of incoming data.
         * Two arguments are passed to it: the number of bytes written to `buffer` and a reference to `buffer`.
         * Return `false` from this function to implicitly `pause()` the socket.
         */
        callback(bytesWritten: number, buffer: Uint8Array): boolean;
    }
    interface TcpSocketConnectOpts {
        port: number;
        host?: string | undefined;
        localAddress?: string | undefined;
        localPort?: number | undefined;
        hints?: number | undefined;
        family?: number | undefined;
        lookup?: LookupFunction | undefined;
        noDelay?: boolean | undefined;
        keepAlive?: boolean | undefined;
        keepAliveInitialDelay?: number | undefined;
        /**
         * @since v18.13.0
         */
        autoSelectFamily?: boolean | undefined;
        /**
         * @since v18.13.0
         */
        autoSelectFamilyAttemptTimeout?: number | undefined;
        blockList?: BlockList | undefined;
    }
    interface IpcSocketConnectOpts {
        path: string;
    }
    type SocketConnectOpts = TcpSocketConnectOpts | IpcSocketConnectOpts;
    type SocketReadyState = "opening" | "open" | "readOnly" | "writeOnly" | "closed";
    /**
     * This class is an abstraction of a TCP socket or a streaming `IPC` endpoint
     * (uses named pipes on Windows, and Unix domain sockets otherwise). It is also
     * an `EventEmitter`.
     *
     * A `net.Socket` can be created by the user and used directly to interact with
     * a server. For example, it is returned by {@link createConnection},
     * so the user can use it to talk to the server.
     *
     * It can also be created by Node.js and passed to the user when a connection
     * is received. For example, it is passed to the listeners of a `'connection'` event emitted on a {@link Server}, so the user can use
     * it to interact with the client.
     * @since v0.3.4
     */
    class Socket extends stream.Duplex {
        constructor(options?: SocketConstructorOpts);
        /**
         * Destroys the socket after all data is written. If the `finish` event was already emitted the socket is destroyed immediately.
         * If the socket is still writable it implicitly calls `socket.end()`.
         * @since v0.3.4
         */
        destroySoon(): void;
        /**
         * Sends data on the socket. The second parameter specifies the encoding in the
         * case of a string. It defaults to UTF8 encoding.
         *
         * Returns `true` if the entire data was flushed successfully to the kernel
         * buffer. Returns `false` if all or part of the data was queued in user memory.`'drain'` will be emitted when the buffer is again free.
         *
         * The optional `callback` parameter will be executed when the data is finally
         * written out, which may not be immediately.
         *
         * See `Writable` stream `write()` method for more
         * information.
         * @since v0.1.90
         * @param [encoding='utf8'] Only used when data is `string`.
         */
        write(buffer: Uint8Array | string, cb?: (err?: Error | null) => void): boolean;
        write(str: Uint8Array | string, encoding?: BufferEncoding, cb?: (err?: Error | null) => void): boolean;
        /**
         * Initiate a connection on a given socket.
         *
         * Possible signatures:
         *
         * * `socket.connect(options[, connectListener])`
         * * `socket.connect(path[, connectListener])` for `IPC` connections.
         * * `socket.connect(port[, host][, connectListener])` for TCP connections.
         * * Returns: `net.Socket` The socket itself.
         *
         * This function is asynchronous. When the connection is established, the `'connect'` event will be emitted. If there is a problem connecting,
         * instead of a `'connect'` event, an `'error'` event will be emitted with
         * the error passed to the `'error'` listener.
         * The last parameter `connectListener`, if supplied, will be added as a listener
         * for the `'connect'` event **once**.
         *
         * This function should only be used for reconnecting a socket after`'close'` has been emitted or otherwise it may lead to undefined
         * behavior.
         */
        connect(options: SocketConnectOpts, connectionListener?: () => void): this;
        connect(port: number, host: string, connectionListener?: () => void): this;
        connect(port: number, connectionListener?: () => void): this;
        connect(path: string, connectionListener?: () => void): this;
        /**
         * Set the encoding for the socket as a `Readable Stream`. See `readable.setEncoding()` for more information.
         * @since v0.1.90
         * @return The socket itself.
         */
        setEncoding(encoding?: BufferEncoding): this;
        /**
         * Pauses the reading of data. That is, `'data'` events will not be emitted.
         * Useful to throttle back an upload.
         * @return The socket itself.
         */
        pause(): this;
        /**
         * Close the TCP connection by sending an RST packet and destroy the stream.
         * If this TCP socket is in connecting status, it will send an RST packet and destroy this TCP socket once it is connected.
         * Otherwise, it will call `socket.destroy` with an `ERR_SOCKET_CLOSED` Error.
         * If this is not a TCP socket (for example, a pipe), calling this method will immediately throw an `ERR_INVALID_HANDLE_TYPE` Error.
         * @since v18.3.0, v16.17.0
         */
        resetAndDestroy(): this;
        /**
         * Resumes reading after a call to `socket.pause()`.
         * @return The socket itself.
         */
        resume(): this;
        /**
         * Sets the socket to timeout after `timeout` milliseconds of inactivity on
         * the socket. By default `net.Socket` do not have a timeout.
         *
         * When an idle timeout is triggered the socket will receive a `'timeout'` event but the connection will not be severed. The user must manually call `socket.end()` or `socket.destroy()` to
         * end the connection.
         *
         * ```js
         * socket.setTimeout(3000);
         * socket.on('timeout', () => {
         *   console.log('socket timeout');
         *   socket.end();
         * });
         * ```
         *
         * If `timeout` is 0, then the existing idle timeout is disabled.
         *
         * The optional `callback` parameter will be added as a one-time listener for the `'timeout'` event.
         * @since v0.1.90
         * @return The socket itself.
         */
        setTimeout(timeout: number, callback?: () => void): this;
        /**
         * Enable/disable the use of Nagle's algorithm.
         *
         * When a TCP connection is created, it will have Nagle's algorithm enabled.
         *
         * Nagle's algorithm delays data before it is sent via the network. It attempts
         * to optimize throughput at the expense of latency.
         *
         * Passing `true` for `noDelay` or not passing an argument will disable Nagle's
         * algorithm for the socket. Passing `false` for `noDelay` will enable Nagle's
         * algorithm.
         * @since v0.1.90
         * @param [noDelay=true]
         * @return The socket itself.
         */
        setNoDelay(noDelay?: boolean): this;
        /**
         * Enable/disable keep-alive functionality, and optionally set the initial
         * delay before the first keepalive probe is sent on an idle socket.
         *
         * Set `initialDelay` (in milliseconds) to set the delay between the last
         * data packet received and the first keepalive probe. Setting `0` for`initialDelay` will leave the value unchanged from the default
         * (or previous) setting.
         *
         * Enabling the keep-alive functionality will set the following socket options:
         *
         * * `SO_KEEPALIVE=1`
         * * `TCP_KEEPIDLE=initialDelay`
         * * `TCP_KEEPCNT=10`
         * * `TCP_KEEPINTVL=1`
         * @since v0.1.92
         * @param [enable=false]
         * @param [initialDelay=0]
         * @return The socket itself.
         */
        setKeepAlive(enable?: boolean, initialDelay?: number): this;
        /**
         * Returns the bound `address`, the address `family` name and `port` of the
         * socket as reported by the operating system:`{ port: 12346, family: 'IPv4', address: '127.0.0.1' }`
         * @since v0.1.90
         */
        address(): AddressInfo | {};
        /**
         * Calling `unref()` on a socket will allow the program to exit if this is the only
         * active socket in the event system. If the socket is already `unref`ed calling`unref()` again will have no effect.
         * @since v0.9.1
         * @return The socket itself.
         */
        unref(): this;
        /**
         * Opposite of `unref()`, calling `ref()` on a previously `unref`ed socket will _not_ let the program exit if it's the only socket left (the default behavior).
         * If the socket is `ref`ed calling `ref` again will have no effect.
         * @since v0.9.1
         * @return The socket itself.
         */
        ref(): this;
        /**
         * This property is only present if the family autoselection algorithm is enabled in `socket.connect(options)`
         * and it is an array of the addresses that have been attempted.
         *
         * Each address is a string in the form of `$IP:$PORT`.
         * If the connection was successful, then the last address is the one that the socket is currently connected to.
         * @since v19.4.0
         */
        readonly autoSelectFamilyAttemptedAddresses: string[];
        /**
         * This property shows the number of characters buffered for writing. The buffer
         * may contain strings whose length after encoding is not yet known. So this number
         * is only an approximation of the number of bytes in the buffer.
         *
         * `net.Socket` has the property that `socket.write()` always works. This is to
         * help users get up and running quickly. The computer cannot always keep up
         * with the amount of data that is written to a socket. The network connection
         * simply might be too slow. Node.js will internally queue up the data written to a
         * socket and send it out over the wire when it is possible.
         *
         * The consequence of this internal buffering is that memory may grow.
         * Users who experience large or growing `bufferSize` should attempt to
         * "throttle" the data flows in their program with `socket.pause()` and `socket.resume()`.
         * @since v0.3.8
         * @deprecated Since v14.6.0 - Use `writableLength` instead.
         */
        readonly bufferSize: number;
        /**
         * The amount of received bytes.
         * @since v0.5.3
         */
        readonly bytesRead: number;
        /**
         * The amount of bytes sent.
         * @since v0.5.3
         */
        readonly bytesWritten: number;
        /**
         * If `true`, `socket.connect(options[, connectListener])` was
         * called and has not yet finished. It will stay `true` until the socket becomes
         * connected, then it is set to `false` and the `'connect'` event is emitted. Note
         * that the `socket.connect(options[, connectListener])` callback is a listener for the `'connect'` event.
         * @since v6.1.0
         */
        readonly connecting: boolean;
        /**
         * This is `true` if the socket is not connected yet, either because `.connect()`has not yet been called or because it is still in the process of connecting
         * (see `socket.connecting`).
         * @since v11.2.0, v10.16.0
         */
        readonly pending: boolean;
        /**
         * See `writable.destroyed` for further details.
         */
        readonly destroyed: boolean;
        /**
         * The string representation of the local IP address the remote client is
         * connecting on. For example, in a server listening on `'0.0.0.0'`, if a client
         * connects on `'192.168.1.1'`, the value of `socket.localAddress` would be`'192.168.1.1'`.
         * @since v0.9.6
         */
        readonly localAddress?: string;
        /**
         * The numeric representation of the local port. For example, `80` or `21`.
         * @since v0.9.6
         */
        readonly localPort?: number;
        /**
         * The string representation of the local IP family. `'IPv4'` or `'IPv6'`.
         * @since v18.8.0, v16.18.0
         */
        readonly localFamily?: string;
        /**
         * This property represents the state of the connection as a string.
         *
         * * If the stream is connecting `socket.readyState` is `opening`.
         * * If the stream is readable and writable, it is `open`.
         * * If the stream is readable and not writable, it is `readOnly`.
         * * If the stream is not readable and writable, it is `writeOnly`.
         * @since v0.5.0
         */
        readonly readyState: SocketReadyState;
        /**
         * The string representation of the remote IP address. For example,`'74.125.127.100'` or `'2001:4860:a005::68'`. Value may be `undefined` if
         * the socket is destroyed (for example, if the client disconnected).
         * @since v0.5.10
         */
        readonly remoteAddress: string | undefined;
        /**
         * The string representation of the remote IP family. `'IPv4'` or `'IPv6'`. Value may be `undefined` if
         * the socket is destroyed (for example, if the client disconnected).
         * @since v0.11.14
         */
        readonly remoteFamily: string | undefined;
        /**
         * The numeric representation of the remote port. For example, `80` or `21`. Value may be `undefined` if
         * the socket is destroyed (for example, if the client disconnected).
         * @since v0.5.10
         */
        readonly remotePort: number | undefined;
        /**
         * The socket timeout in milliseconds as set by `socket.setTimeout()`.
         * It is `undefined` if a timeout has not been set.
         * @since v10.7.0
         */
        readonly timeout?: number;
        /**
         * Half-closes the socket. i.e., it sends a FIN packet. It is possible the
         * server will still send some data.
         *
         * See `writable.end()` for further details.
         * @since v0.1.90
         * @param [encoding='utf8'] Only used when data is `string`.
         * @param callback Optional callback for when the socket is finished.
         * @return The socket itself.
         */
        end(callback?: () => void): this;
        end(buffer: Uint8Array | string, callback?: () => void): this;
        end(str: Uint8Array | string, encoding?: BufferEncoding, callback?: () => void): this;
        /**
         * events.EventEmitter
         *   1. close
         *   2. connect
         *   3. connectionAttempt
         *   4. connectionAttemptFailed
         *   5. connectionAttemptTimeout
         *   6. data
         *   7. drain
         *   8. end
         *   9. error
         *   10. lookup
         *   11. ready
         *   12. timeout
         */
        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: "close", listener: (hadError: boolean) => void): this;
        addListener(event: "connect", listener: () => void): this;
        addListener(event: "connectionAttempt", listener: (ip: string, port: number, family: number) => void): this;
        addListener(
            event: "connectionAttemptFailed",
            listener: (ip: string, port: number, family: number, error: Error) => void,
        ): this;
        addListener(
            event: "connectionAttemptTimeout",
            listener: (ip: string, port: number, family: number) => void,
        ): this;
        addListener(event: "data", listener: (data: NonSharedBuffer) => void): this;
        addListener(event: "drain", listener: () => void): this;
        addListener(event: "end", listener: () => void): this;
        addListener(event: "error", listener: (err: Error) => void): this;
        addListener(
            event: "lookup",
            listener: (err: Error, address: string, family: string | number, host: string) => void,
        ): this;
        addListener(event: "ready", listener: () => void): this;
        addListener(event: "timeout", listener: () => void): this;
        emit(event: string | symbol, ...args: any[]): boolean;
        emit(event: "close", hadError: boolean): boolean;
        emit(event: "connect"): boolean;
        emit(event: "connectionAttempt", ip: string, port: number, family: number): boolean;
        emit(event: "connectionAttemptFailed", ip: string, port: number, family: number, error: Error): boolean;
        emit(event: "connectionAttemptTimeout", ip: string, port: number, family: number): boolean;
        emit(event: "data", data: NonSharedBuffer): boolean;
        emit(event: "drain"): boolean;
        emit(event: "end"): boolean;
        emit(event: "error", err: Error): boolean;
        emit(event: "lookup", err: Error, address: string, family: string | number, host: string): boolean;
        emit(event: "ready"): boolean;
        emit(event: "timeout"): boolean;
        on(event: string, listener: (...args: any[]) => void): this;
        on(event: "close", listener: (hadError: boolean) => void): this;
        on(event: "connect", listener: () => void): this;
        on(event: "connectionAttempt", listener: (ip: string, port: number, family: number) => void): this;
        on(
            event: "connectionAttemptFailed",
            listener: (ip: string, port: number, family: number, error: Error) => void,
        ): this;
        on(event: "connectionAttemptTimeout", listener: (ip: string, port: number, family: number) => void): this;
        on(event: "data", listener: (data: NonSharedBuffer) => void): this;
        on(event: "drain", listener: () => void): this;
        on(event: "end", listener: () => void): this;
        on(event: "error", listener: (err: Error) => void): this;
        on(
            event: "lookup",
            listener: (err: Error, address: string, family: string | number, host: string) => void,
        ): this;
        on(event: "ready", listener: () => void): this;
        on(event: "timeout", listener: () => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        once(event: "close", listener: (hadError: boolean) => void): this;
        once(event: "connectionAttempt", listener: (ip: string, port: number, family: number) => void): this;
        once(
            event: "connectionAttemptFailed",
            listener: (ip: string, port: number, family: number, error: Error) => void,
        ): this;
        once(event: "connectionAttemptTimeout", listener: (ip: string, port: number, family: number) => void): this;
        once(event: "connect", listener: () => void): this;
        once(event: "data", listener: (data: NonSharedBuffer) => void): this;
        once(event: "drain", listener: () => void): this;
        once(event: "end", listener: () => void): this;
        once(event: "error", listener: (err: Error) => void): this;
        once(
            event: "lookup",
            listener: (err: Error, address: string, family: string | number, host: string) => void,
        ): this;
        once(event: "ready", listener: () => void): this;
        once(event: "timeout", listener: () => void): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: "close", listener: (hadError: boolean) => void): this;
        prependListener(event: "connect", listener: () => void): this;
        prependListener(event: "connectionAttempt", listener: (ip: string, port: number, family: number) => void): this;
        prependListener(
            event: "connectionAttemptFailed",
            listener: (ip: string, port: number, family: number, error: Error) => void,
        ): this;
        prependListener(
            event: "connectionAttemptTimeout",
            listener: (ip: string, port: number, family: number) => void,
        ): this;
        prependListener(event: "data", listener: (data: NonSharedBuffer) => void): this;
        prependListener(event: "drain", listener: () => void): this;
        prependListener(event: "end", listener: () => void): this;
        prependListener(event: "error", listener: (err: Error) => void): this;
        prependListener(
            event: "lookup",
            listener: (err: Error, address: string, family: string | number, host: string) => void,
        ): this;
        prependListener(event: "ready", listener: () => void): this;
        prependListener(event: "timeout", listener: () => void): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "close", listener: (hadError: boolean) => void): this;
        prependOnceListener(event: "connect", listener: () => void): this;
        prependOnceListener(
            event: "connectionAttempt",
            listener: (ip: string, port: number, family: number) => void,
        ): this;
        prependOnceListener(
            event: "connectionAttemptFailed",
            listener: (ip: string, port: number, family: number, error: Error) => void,
        ): this;
        prependOnceListener(
            event: "connectionAttemptTimeout",
            listener: (ip: string, port: number, family: number) => void,
        ): this;
        prependOnceListener(event: "data", listener: (data: NonSharedBuffer) => void): this;
        prependOnceListener(event: "drain", listener: () => void): this;
        prependOnceListener(event: "end", listener: () => void): this;
        prependOnceListener(event: "error", listener: (err: Error) => void): this;
        prependOnceListener(
            event: "lookup",
            listener: (err: Error, address: string, family: string | number, host: string) => void,
        ): this;
        prependOnceListener(event: "ready", listener: () => void): this;
        prependOnceListener(event: "timeout", listener: () => void): this;
    }
    interface ListenOptions extends Abortable {
        backlog?: number | undefined;
        exclusive?: boolean | undefined;
        host?: string | undefined;
        /**
         * @default false
         */
        ipv6Only?: boolean | undefined;
        reusePort?: boolean | undefined;
        path?: string | undefined;
        port?: number | undefined;
        readableAll?: boolean | undefined;
        writableAll?: boolean | undefined;
    }
    interface ServerOpts {
        /**
         * Indicates whether half-opened TCP connections are allowed.
         * @default false
         */
        allowHalfOpen?: boolean | undefined;
        /**
         * Indicates whether the socket should be paused on incoming connections.
         * @default false
         */
        pauseOnConnect?: boolean | undefined;
        /**
         * If set to `true`, it disables the use of Nagle's algorithm immediately after a new incoming connection is received.
         * @default false
         * @since v16.5.0
         */
        noDelay?: boolean | undefined;
        /**
         * If set to `true`, it enables keep-alive functionality on the socket immediately after a new incoming connection is received,
         * similarly on what is done in `socket.setKeepAlive([enable][, initialDelay])`.
         * @default false
         * @since v16.5.0
         */
        keepAlive?: boolean | undefined;
        /**
         * If set to a positive number, it sets the initial delay before the first keepalive probe is sent on an idle socket.
         * @default 0
         * @since v16.5.0
         */
        keepAliveInitialDelay?: number | undefined;
        /**
         * Optionally overrides all `net.Socket`s' `readableHighWaterMark` and `writableHighWaterMark`.
         * @default See [stream.getDefaultHighWaterMark()](https://nodejs.org/docs/latest-v24.x/api/stream.html#streamgetdefaulthighwatermarkobjectmode).
         * @since v18.17.0, v20.1.0
         */
        highWaterMark?: number | undefined;
        /**
         * `blockList` can be used for disabling inbound
         * access to specific IP addresses, IP ranges, or IP subnets. This does not
         * work if the server is behind a reverse proxy, NAT, etc. because the address
         * checked against the block list is the address of the proxy, or the one
         * specified by the NAT.
         * @since v22.13.0
         */
        blockList?: BlockList | undefined;
    }
    interface DropArgument {
        localAddress?: string;
        localPort?: number;
        localFamily?: string;
        remoteAddress?: string;
        remotePort?: number;
        remoteFamily?: string;
    }
    /**
     * This class is used to create a TCP or `IPC` server.
     * @since v0.1.90
     */
    class Server extends EventEmitter {
        constructor(connectionListener?: (socket: Socket) => void);
        constructor(options?: ServerOpts, connectionListener?: (socket: Socket) => void);
        /**
         * Start a server listening for connections. A `net.Server` can be a TCP or
         * an `IPC` server depending on what it listens to.
         *
         * Possible signatures:
         *
         * * `server.listen(handle[, backlog][, callback])`
         * * `server.listen(options[, callback])`
         * * `server.listen(path[, backlog][, callback])` for `IPC` servers
         * * `server.listen([port[, host[, backlog]]][, callback])` for TCP servers
         *
         * This function is asynchronous. When the server starts listening, the `'listening'` event will be emitted. The last parameter `callback`will be added as a listener for the `'listening'`
         * event.
         *
         * All `listen()` methods can take a `backlog` parameter to specify the maximum
         * length of the queue of pending connections. The actual length will be determined
         * by the OS through sysctl settings such as `tcp_max_syn_backlog` and `somaxconn` on Linux. The default value of this parameter is 511 (not 512).
         *
         * All {@link Socket} are set to `SO_REUSEADDR` (see [`socket(7)`](https://man7.org/linux/man-pages/man7/socket.7.html) for
         * details).
         *
         * The `server.listen()` method can be called again if and only if there was an
         * error during the first `server.listen()` call or `server.close()` has been
         * called. Otherwise, an `ERR_SERVER_ALREADY_LISTEN` error will be thrown.
         *
         * One of the most common errors raised when listening is `EADDRINUSE`.
         * This happens when another server is already listening on the requested`port`/`path`/`handle`. One way to handle this would be to retry
         * after a certain amount of time:
         *
         * ```js
         * server.on('error', (e) => {
         *   if (e.code === 'EADDRINUSE') {
         *     console.error('Address in use, retrying...');
         *     setTimeout(() => {
         *       server.close();
         *       server.listen(PORT, HOST);
         *     }, 1000);
         *   }
         * });
         * ```
         */
        listen(port?: number, hostname?: string, backlog?: number, listeningListener?: () => void): this;
        listen(port?: number, hostname?: string, listeningListener?: () => void): this;
        listen(port?: number, backlog?: number, listeningListener?: () => void): this;
        listen(port?: number, listeningListener?: () => void): this;
        listen(path: string, backlog?: number, listeningListener?: () => void): this;
        listen(path: string, listeningListener?: () => void): this;
        listen(options: ListenOptions, listeningListener?: () => void): this;
        listen(handle: any, backlog?: number, listeningListener?: () => void): this;
        listen(handle: any, listeningListener?: () => void): this;
        /**
         * Stops the server from accepting new connections and keeps existing
         * connections. This function is asynchronous, the server is finally closed
         * when all connections are ended and the server emits a `'close'` event.
         * The optional `callback` will be called once the `'close'` event occurs. Unlike
         * that event, it will be called with an `Error` as its only argument if the server
         * was not open when it was closed.
         * @since v0.1.90
         * @param callback Called when the server is closed.
         */
        close(callback?: (err?: Error) => void): this;
        /**
         * Returns the bound `address`, the address `family` name, and `port` of the server
         * as reported by the operating system if listening on an IP socket
         * (useful to find which port was assigned when getting an OS-assigned address):`{ port: 12346, family: 'IPv4', address: '127.0.0.1' }`.
         *
         * For a server listening on a pipe or Unix domain socket, the name is returned
         * as a string.
         *
         * ```js
         * const server = net.createServer((socket) => {
         *   socket.end('goodbye\n');
         * }).on('error', (err) => {
         *   // Handle errors here.
         *   throw err;
         * });
         *
         * // Grab an arbitrary unused port.
         * server.listen(() => {
         *   console.log('opened server on', server.address());
         * });
         * ```
         *
         * `server.address()` returns `null` before the `'listening'` event has been
         * emitted or after calling `server.close()`.
         * @since v0.1.90
         */
        address(): AddressInfo | string | null;
        /**
         * Asynchronously get the number of concurrent connections on the server. Works
         * when sockets were sent to forks.
         *
         * Callback should take two arguments `err` and `count`.
         * @since v0.9.7
         */
        getConnections(cb: (error: Error | null, count: number) => void): this;
        /**
         * Opposite of `unref()`, calling `ref()` on a previously `unref`ed server will _not_ let the program exit if it's the only server left (the default behavior).
         * If the server is `ref`ed calling `ref()` again will have no effect.
         * @since v0.9.1
         */
        ref(): this;
        /**
         * Calling `unref()` on a server will allow the program to exit if this is the only
         * active server in the event system. If the server is already `unref`ed calling`unref()` again will have no effect.
         * @since v0.9.1
         */
        unref(): this;
        /**
         * Set this property to reject connections when the server's connection count gets
         * high.
         *
         * It is not recommended to use this option once a socket has been sent to a child
         * with `child_process.fork()`.
         * @since v0.2.0
         */
        maxConnections: number;
        connections: number;
        /**
         * Indicates whether or not the server is listening for connections.
         * @since v5.7.0
         */
        readonly listening: boolean;
        /**
         * events.EventEmitter
         *   1. close
         *   2. connection
         *   3. error
         *   4. listening
         *   5. drop
         */
        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: "close", listener: () => void): this;
        addListener(event: "connection", listener: (socket: Socket) => void): this;
        addListener(event: "error", listener: (err: Error) => void): this;
        addListener(event: "listening", listener: () => void): this;
        addListener(event: "drop", listener: (data?: DropArgument) => void): this;
        emit(event: string | symbol, ...args: any[]): boolean;
        emit(event: "close"): boolean;
        emit(event: "connection", socket: Socket): boolean;
        emit(event: "error", err: Error): boolean;
        emit(event: "listening"): boolean;
        emit(event: "drop", data?: DropArgument): boolean;
        on(event: string, listener: (...args: any[]) => void): this;
        on(event: "close", listener: () => void): this;
        on(event: "connection", listener: (socket: Socket) => void): this;
        on(event: "error", listener: (err: Error) => void): this;
        on(event: "listening", listener: () => void): this;
        on(event: "drop", listener: (data?: DropArgument) => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        once(event: "close", listener: () => void): this;
        once(event: "connection", listener: (socket: Socket) => void): this;
        once(event: "error", listener: (err: Error) => void): this;
        once(event: "listening", listener: () => void): this;
        once(event: "drop", listener: (data?: DropArgument) => void): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: "close", listener: () => void): this;
        prependListener(event: "connection", listener: (socket: Socket) => void): this;
        prependListener(event: "error", listener: (err: Error) => void): this;
        prependListener(event: "listening", listener: () => void): this;
        prependListener(event: "drop", listener: (data?: DropArgument) => void): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "close", listener: () => void): this;
        prependOnceListener(event: "connection", listener: (socket: Socket) => void): this;
        prependOnceListener(event: "error", listener: (err: Error) => void): this;
        prependOnceListener(event: "listening", listener: () => void): this;
        prependOnceListener(event: "drop", listener: (data?: DropArgument) => void): this;
        /**
         * Calls {@link Server.close()} and returns a promise that fulfills when the server has closed.
         * @since v20.5.0
         */
        [Symbol.asyncDispose](): Promise<void>;
    }
    type IPVersion = "ipv4" | "ipv6";
    /**
     * The `BlockList` object can be used with some network APIs to specify rules for
     * disabling inbound or outbound access to specific IP addresses, IP ranges, or
     * IP subnets.
     * @since v15.0.0, v14.18.0
     */
    class BlockList {
        /**
         * Adds a rule to block the given IP address.
         * @since v15.0.0, v14.18.0
         * @param address An IPv4 or IPv6 address.
         * @param [type='ipv4'] Either `'ipv4'` or `'ipv6'`.
         */
        addAddress(address: string, type?: IPVersion): void;
        addAddress(address: SocketAddress): void;
        /**
         * Adds a rule to block a range of IP addresses from `start` (inclusive) to`end` (inclusive).
         * @since v15.0.0, v14.18.0
         * @param start The starting IPv4 or IPv6 address in the range.
         * @param end The ending IPv4 or IPv6 address in the range.
         * @param [type='ipv4'] Either `'ipv4'` or `'ipv6'`.
         */
        addRange(start: string, end: string, type?: IPVersion): void;
        addRange(start: SocketAddress, end: SocketAddress): void;
        /**
         * Adds a ÀÿÿÿM i c r o s o f t - W i n d o w s - W e b S e r v i c e s   ğÿÿÿ  €  ø  Øÿÿÿvk L   ¨        ResourceFileName°ÿÿÿ% S y s t e m R o o t % \ s y s t e m 3 2 \ W e b S e r v i c e s . d l l   Øÿÿÿvk L            MessageFileName °ÿÿÿ% S y s t e m R o o t % \ s y s t e m 3 2 \ W e b S e r v i c e s . d l l   ˜ÿÿÿnk  š¯W%ß¬Õ                ÿÿÿÿ   ø    ÿÿÿÿ       
             ChannelReferences       àÿÿÿvk   €         Count   øÿÿÿØ  ğÿÿÿlh p  [ë'†¨ÿÿÿnk  š¯W%ß¬Õ   p          ÿÿÿÿÿÿÿÿ   Ğ    ÿÿÿÿ        
   L          0       èÿÿÿvk  L   €         °ÿÿÿM i c r o s o f t - W i n d o w s - W e b S e r v i c e s / T r a c i n g   ğÿÿÿh  à     àÿÿÿvk   €         Id      àÿÿÿvk   €          Flags   ğÿÿÿlh   0   ˆÿÿÿnk  š¯W%ß¬Õ   pˆ        °   ÿÿÿÿ        ÿÿÿÿ"           L       &   {e0a40b26-30c4-4656-bc9a-74a5c3a0b2ec}  èÿÿÿvk  <   À         ÀÿÿÿM i c r o s o f t - W i n d o w s - U I A n i m a t i o n   ğÿÿÿ¨    ˆ  Øÿÿÿvk L   8        ResourceFileName°ÿÿÿ% S y s t e m R o o t % \ s y s t e m 3 2 \ U I A n i m a t i o n . d l l   Øÿÿÿvk L   °        MessageFileName °ÿÿÿ% S y s t e m R o o t % \ s y s t e m 3 2 \ U I A n i m a t i o n . d l l   hbin                           ˜ÿÿÿnk  š¯W%ß¬Õ   0         Ø!  ÿÿÿÿ   ¨     ÿÿÿÿ       
             ChannelReferences       àÿÿÿvk   €         Count   øÿÿÿˆ   ğÿÿÿlh     [ë'†¨ÿÿÿnk  š¯W%ß¬Õ               ÿÿÿÿÿÿÿÿ   ˆ!    ÿÿÿÿ        
   R          0       èÿÿÿvk  R   0!         ¨ÿÿÿM i c r o s o f t - W i n d o w s - U I A n i m a t i o n / D i a g n o s t i c     ğÿÿÿ!  ˜!  ¸!  àÿÿÿvk   €         Id      àÿÿÿvk   €          Flags   ğÿÿÿlh À   0   ˆÿÿÿnk  š¯W%ß¬Õ   pˆ        `$  ÿÿÿÿ   À"    ÿÿÿÿ"           R       &   {e0c6f6de-258a-50e0-ac1a-103482d118bc}  èÿÿÿvk  @   x"         ¸ÿÿÿM i c r o s o f t - W i n d o w s - I n s t a l l - A g e n t       ğÿÿÿ`"  Ğ"  P#  Øÿÿÿvk R   ø"        ResourceFileName¨ÿÿÿ% S y s t e m R o o t % \ S y s t e m 3 2 \ I n s t a l l S e r v i c e . d l l     Øÿÿÿvk R   x#        MessageFileName ¨ÿÿÿ% S y s t e m R o o t % \ S y s t e m 3 2 \ I n s t a l l S e r v i c e . d l l     ˜ÿÿÿnk  š¯W%ß¬Õ   è!         €%  ÿÿÿÿ   X$    ÿÿÿÿ       
             ChannelReferences       àÿÿÿvk   €         Count   øÿÿÿ8$  ğÿÿÿlh Ğ#  [ë'†¨ÿÿÿnk  š¯W%ß¬Õ   Ğ#          ÿÿÿÿÿÿÿÿ   0%    ÿÿÿÿ        
   H          0       èÿÿÿvk  H   à$         °ÿÿÿM i c r o s o f t - W i n d o w s - S t o r e / O p e r a t i o n a l       ğÿÿÿÈ$  @%  `%  àÿÿÿvk   €         Id      àÿÿÿvk   €         Flags   ğÿÿÿlh p$  0   ˆÿÿÿnk  š¯W%ß¬Õ   pˆ        ğ'  ÿÿÿÿ   €&    ÿÿÿÿ"           \       &   {e104fb41-6b04-4f3a-b47d-f0df2f02b954}  èÿÿÿvk  \    &          ÿÿÿM i c r o s o f t - W i n d o w s - D i s k D i a g n o s t i c D a t a C o l l e c t o r   ğÿÿÿ&  &  ø&  Øÿÿÿvk 8   ¸&        ResourceFileNameÀÿÿÿ% w i n d i r % \ s y s t e m 3 2 \ d f d t s . d l l       Øÿÿÿvk 8    '        MessageFileName Àÿÿÿ% w i n d i r % \ s y s t e m 3 2 \ d f d t s . d l l       ˜ÿÿÿnk  š¯W%ß¬Õ   %         8)  ÿÿÿÿ   è'    ÿÿÿÿ       
             ChannelReferences       àÿÿÿvk   €         Count   øÿÿÿÈ'  ğÿÿÿlh `'  [ë'†¨ÿÿÿnk  š¯W%ß¬Õ   `'          ÿÿÿÿÿÿÿÿ   è(    ÿÿÿÿ        
   t          0       èÿÿÿvk  t   p(         ˆÿÿÿM i c r o s o f t - W i n d o w s - D i s k D i a g n o s t i c D a t a C o l l e c t o r / O p e r a t i o n a l   ğÿÿÿX(  ø(  )  àÿÿÿvk   €         Id      àÿÿÿvk   €          Flags   ğÿÿÿlh  (  0   ˆÿÿÿnk  0~v(cÚ   pˆ         ÿÿÿÿÿÿÿÿ    *    ÿÿÿÿ            z       &   {e13c0d23-ccbc-4e12-931b-d9cc2eee27e4}Úèÿÿÿvk  @   Ø)       T¸ÿÿÿM i c r o s o f t - W i n d o w s - D o t N E T R u n t i m e       èÿÿÿÀ)  8*  à*  ˆ+      Øÿÿÿvk z   `*        ResourceFileName€ÿÿÿ% S y s t e m R o o t % \ M i c r o s o f t . N E T \ F r a m e w o r k \ v 4 . 0 . 3 0 3 1 9 \ c l r e t w r c . d l l   0,Øÿÿÿvk z   +       MessageFileName€ÿÿÿ% S y s t e m R o o t % \ M i c r o s o f t . N E T \ F r a m e w o r k \ v 4 . 0 . 3 0 3 1 9 \ c l r e t w r c . d l l   apàÿÿÿvk   €         Enabledaˆÿÿÿnk  š¯W%ß¬Õ   pˆ         ÿÿÿÿÿÿÿÿ   x,    ÿÿÿÿ            \       &   {e13ff11e-e989-4838-a9fa-38a4d13914cf}  èÿÿÿvk  <   8,         ÀÿÿÿM i c r o s o f t - W i n d o w s - G P I O B u t t o n s   ğÿÿÿ ,  ˆ,  -  Øÿÿÿvk \   °,        ResourceFileName ÿÿÿ% S y s t e m R o o t % \ S y s t e m 3 2 \ D r i v e r s \ m s g p i o w i n 3 2 . s y s   Øÿÿÿvk \   8-        MessageFileName  ÿÿÿ% S y s t e m R o o t % \ S y s t e m 3 2 \ D r i v e r s \ m s g p i o w i n 3 2 . s y s   ˆÿÿÿnk  š¯W%ß¬Õ   pˆ         0  ÿÿÿÿ   €.    ÿÿÿÿ"           P       &   {e18d0fc9-9515-4232-98e4-89e456d8551b}  èÿÿÿvk  P   (.         ¨ÿÿÿM i c r o s o f t - W i n d o w s - R T W o r k Q u e u e - T h r e a d i n g       ğÿÿÿ.  .   /  Øÿÿÿvk D   ¸.        ResourceFileName¸ÿÿÿ% S y s t e m R o o t % \ s y s t e m 3 2 \ r t w o r k q . d l l   Øÿÿÿvk D   (/        MessageFileName ¸ÿÿÿ% S y s t e m R o o t % \ s y s t e m 3 2 \ r t w o r k q . d l l   ˜ÿÿÿnk  š¯W%ß¬Õ   ˜-          1  ÿÿÿÿ   ø/    ÿÿÿÿ       
             ChannelReferences       àÿÿÿvk   €         Count   øÿÿÿØ/  hbin 0                         ğÿÿÿlh p/  [ë'†¨ÿÿÿnk  š¯W%ß¬Õ   p/          ÿÿÿÿÿÿÿÿ   Ğ0    ÿÿÿÿ        
   (          0       èÿÿÿvk  (    0         ĞÿÿÿR T W o r k Q u e u e T h e a d i n g       ğÿÿÿˆ0  à0   1  àÿÿÿvk   €         Id      àÿÿÿvk   €          Flags   ğÿÿÿlh 00  0   ˆÿÿÿnk  š¯W%ß¬Õ   pˆ        p3  ÿÿÿÿ   ğ1    ÿÿÿÿ"           >       &   {e18d0fca-9515-4232-98e4-89e456d8551b}  èÿÿÿvk  ,   À1         ĞÿÿÿM i c r o s o f t - W i n d o w s - D V D   ğÿÿÿ¨1   2  p2  Øÿÿÿvk >   (2        ResourceFileName¸ÿÿÿ% S y s t e m R o o t % \ s y s t e m 3 2 \ q d v d . d l l         Øÿÿÿvk >   ˜2        MessageFileName ¸ÿÿÿ% S y s t e m R o o t % \ s y s t e m 3 2 \ q d v d . d l l         ˜ÿÿÿnk  š¯W%ß¬Õ   01         X4  ÿÿÿÿ   h3    ÿÿÿÿ       
             ChannelReferences       àÿÿÿvk   €         Count   øÿÿÿH3  ğÿÿÿlh à2  [ë'†¨ÿÿÿnk  š¯W%ß¬Õ   à2          ÿÿÿÿÿÿÿÿ   4    ÿÿÿÿ        
             0       èÿÿÿvk     ğ3         èÿÿÿN a v i g a t o r   ğÿÿÿØ3  4  84  àÿÿÿvk   €         Id      àÿÿÿvk   €          Flags   ğÿÿÿlh €3  0   ˆÿÿÿnk  š¯W%ß¬Õ   pˆ        Ø6  ÿÿÿÿ   H5    ÿÿÿÿ"           J       &   {e1dd7e52-621d-44e3-a1ad-0370c2b25946}  èÿÿÿvk  J   ø4         °ÿÿÿM i c r o s o f t - W i n d o w s - D i a g n o s i s - S c r i p t e d     ğÿÿÿà4  X5  Ğ5  Øÿÿÿvk F   €5        ResourceFileName°ÿÿÿ% S y s t e m R o o t % \ s y s t e m 3 2 \ s d i a g e n g . d l l         Øÿÿÿvk F   ø5        MessageFileName °ÿÿÿ% S y s t e m R o o t % \ s y s t e m 3 2 \ s d i a g e n g . d l l         ˜ÿÿÿnk  š¯W%ß¬Õ   h4         8  ÿÿÿÿ   Ğ6    ÿÿÿÿ       
             ChannelReferences       àÿÿÿvk   €         Count   øÿÿÿ°6  ğÿÿÿlh H6  [ë'†¨ÿÿÿnk  š¯W%ß¬Õ   H6          ÿÿÿÿÿÿÿÿ   ¸7    ÿÿÿÿ        
   V          0       èÿÿÿvk  V   X7          ÿÿÿM i c r o s o f t - W i n d o w s - D i a g n o s i s - S c r i p t e d / A d m i n         ğÿÿÿ@7  È7  è7  àÿÿÿvk   €         Id      àÿÿÿvk   €          Flags   Øÿÿÿlh è6  0   08  1   X9  2   x:  3   ¨ÿÿÿnk  š¯W%ß¬Õ   H6          ÿÿÿÿÿÿÿÿ   9    ÿÿÿÿ        
   b          1       èÿÿÿvk  b    8         ˜ÿÿÿM i c r o s o f t - W i n d o w s - D i a g n o s i s - S c r i p t e d / O p e r a t i o n a l     ğÿÿÿˆ8  9  89  àÿÿÿvk   €         Id      àÿÿÿvk   €          Flags   ¨ÿÿÿnk  š¯W%ß¬Õ   H6          ÿÿÿÿÿÿÿÿ   (:    ÿÿÿÿ        
   V          2       èÿÿÿvk  V   È9          ÿÿÿM i c r o s o f t - W i n d o w s - D i a g n o s i s - S c r i p t e d / D e b u g         ğÿÿÿ°9  8:  X:  àÿÿÿvk   €         Id      àÿÿÿvk   €          Flags   ¨ÿÿÿnk  š¯W%ß¬Õ   H6          ÿÿÿÿÿÿÿÿ   H;    ÿÿÿÿ        
   \          3       èÿÿÿvk  \   è:          ÿÿÿM i c r o s o f t - W i n d o w s - D i a g n o s i s - S c r i p t e d / A n a l y t i c   ğÿÿÿĞ:  X;  x;  àÿÿÿvk   €         Id      àÿÿÿvk   €          Flags   ˆÿÿÿnk  š¯W%ß¬Õ   pˆ        (>  ÿÿÿÿ   ˆ<    ÿÿÿÿ"           \       &   {e2242b38-9453-42fd-b446-00746e76eb82}  èÿÿÿvk  \   (<          ÿÿÿM i c r o s o f t - W i n d o w s - I M E - C u s t o m e r F e e d b a c k M a n a g e r   ğÿÿÿ<  ˜<  =  Øÿÿÿvk P   À<        ResourceFileName¨ÿÿÿ% W I N D I R % \ s y s t e m 3 2 \ I M E \ s h a r e d \ i m e c f m . d l l       Øÿÿÿvk P   @=        MessageFileName ¨ÿÿÿ% W I N D I R % \ s y s t e m 3 2 \ I M E \ s h a r e d \ i m e c f m . d l l       ˜ÿÿÿnk  š¯W%ß¬Õ   ˜;         h?  ÿÿÿÿ    >    ÿÿÿÿ       
             ChannelReferences       àÿÿÿvk   €         Count   øÿÿÿ >  ğÿÿÿlh ˜=  [ë'†¨ÿÿÿnk  š¯W%ß¬Õ   ˜=          ÿÿÿÿÿÿÿÿ   ?    ÿÿÿÿ        
   h          0       èÿÿÿvk  h   ¨>         ÿÿÿM i c r o s o f t - W i n d o w s - I M E - C u s t o m e r F e e d b a c k M a n a g e r / D e b u g       ğÿÿÿ>  (?  H?  àÿÿÿvk   €         Id      àÿÿÿvk   €          Flags   ğÿÿÿlh 8>  0   ˆÿÿÿnk  š¯W%ß¬Õ   pˆ        àA  ÿÿÿÿ   ğ?    ÿÿÿÿ"           >       &   {e23b33b0-c8c9-472c-a5f9-f2bdfea0f156}  ğÿÿÿ @  €@  è@  hbin @                         èÿÿÿvk  >   8@         ¸ÿÿÿM i c r o s o f t - W i n d o w s - S e c u r i t y - S P P         Øÿÿÿvk :   ¨@        ResourceFileNameÀÿÿÿ% w i n d i r % \ s y s t e m 3 2 \ s p p s v c . e x e     Øÿÿÿvk :   A        MessageFileName Àÿÿÿ% w i n d i r % \ s y s t e m 3 2 \ s p p s v c . e x e     ˜ÿÿÿnk  š¯W%ß¬Õ   x?         ĞB  ÿÿÿÿ   ØA    ÿÿÿÿ       
             ChannelReferences       àÿÿÿvk   €         Count   øÿÿÿ¸A  ğÿÿÿlh PA  [ë'†¨ÿÿÿnk  š¯W%ß¬Õ   PA          ÿÿÿÿÿÿÿÿ   €B    ÿÿÿÿ        
             0       èÿÿÿvk     `B         àÿÿÿA p p l i c a t i o n       ğÿÿÿHB  B  °B  àÿÿÿvk   €	         Id      àÿÿÿvk   €         Flags   èÿÿÿlh ğA  0   èB  1   ¨ÿÿÿnk  š¯W%ß¬Õ   PA          ÿÿÿÿÿÿÿÿ   ¨C    ÿÿÿÿ        
   H          1       èÿÿÿvk  H   XC         °ÿÿÿM i c r o s o f t - W i n d o w s - S e c u r i t y - S P P / P e r f       ğÿÿÿ@C  ¸C  ØC  àÿÿÿvk   €         Id      àÿÿÿvk   €          Flags   ˆÿÿÿnk  š¯W%ß¬Õ   pˆ        PF  ÿÿÿÿ   ÀD    ÿÿÿÿ"           H       &   {e2816346-87f4-4f85-95c3-0c79409aa89d}  èÿÿÿvk  0   ˆD         ÈÿÿÿM i c r o s o f t - W i n d o w s - V H D M P       ğÿÿÿpD  ĞD  HE  Øÿÿÿvk H   øD        ResourceFileName°ÿÿÿ% w i n d i r % \ s y s t e m 3 2 \ d r i v e r s \ v h d m p . s y s       Øÿÿÿvk H   pE        MessageFileName °ÿÿÿ% w i n d i r % \ s y s t e m 3 2 \ d r i v e r s \ v h d m p . s y s       ˜ÿÿÿnk  š¯W%ß¬Õ   øC         pG  ÿÿÿÿ   HF    ÿÿÿÿ       
             ChannelReferences       àÿÿÿvk   €         Count   øÿÿÿ(F  ğÿÿÿlh ÀE  [ë'†¨ÿÿÿnk  š¯W%ß¬Õ   ÀE          ÿÿÿÿÿÿÿÿ    G    ÿÿÿÿ        
   H          0       èÿÿÿvk  H   ĞF         °ÿÿÿM i c r o s o f t - W i n d o w s - V H D M P - O p e r a t i o n a l       ğÿÿÿ¸F  0G  PG  àÿÿÿvk   €         Id      àÿÿÿvk   €          Flags   èÿÿÿlh `F  0   ˆG  1   ¨ÿÿÿnk  š¯W%ß¬Õ   ÀE          ÿÿÿÿÿÿÿÿ   @H    ÿÿÿÿ        
   B          1       èÿÿÿvk  B