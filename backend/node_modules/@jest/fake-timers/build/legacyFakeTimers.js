'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.default = void 0;
function _util() {
  const data = require('util');
  _util = function () {
    return data;
  };
  return data;
}
function _jestMessageUtil() {
  const data = require('jest-message-util');
  _jestMessageUtil = function () {
    return data;
  };
  return data;
}
function _jestUtil() {
  const data = require('jest-util');
  _jestUtil = function () {
    return data;
  };
  return data;
}
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/* eslint-disable local/prefer-spread-eventually */

const MS_IN_A_YEAR = 31536000000;
class FakeTimers {
  _cancelledTicks;
  _config;
  _disposed;
  _fakeTimerAPIs;
  _fakingTime = false;
  _global;
  _immediates;
  _maxLoops;
  _moduleMocker;
  _now;
  _ticks;
  _timerAPIs;
  _timers;
  _uuidCounter;
  _timerConfig;
  constructor({global, moduleMocker, timerConfig, config, maxLoops}) {
    this._global = global;
    this._timerConfig = timerConfig;
    this._config = config;
    this._maxLoops = maxLoops || 100000;
    this._uuidCounter = 1;
    this._moduleMocker = moduleMocker;

    // Store original timer APIs for future reference
    this._timerAPIs = {
      cancelAnimationFrame: global.cancelAnimationFrame,
      clearImmediate: global.clearImmediate,
      clearInterval: global.clearInterval,
      clearTimeout: global.clearTimeout,
      nextTick: global.process && global.process.nextTick,
      requestAnimationFrame: global.requestAnimationFrame,
      setImmediate: global.setImmediate,
      setInterval: global.setInterval,
      setTimeout: global.setTimeout
    };
    this._disposed = false;
    this.reset();
  }
  clearAllTimers() {
    this._immediates = [];
    this._timers.clear();
  }
  dispose() {
    this._disposed = true;
    this.clearAllTimers();
  }
  reset() {
    this._cancelledTicks = {};
    this._now = 0;
    this._ticks = [];
    this._immediates = [];
    this._timers = new Map();
  }
  now() {
    if (this._fakingTime) {
      return this._now;
    }
    return Date.now();
  }
  runAllTicks() {
    this._checkFakeTimers();
    // Only run a generous number of ticks and then bail.
    // This is just to help avoid recursive loops
    let i;
    for (i = 0; i < this._maxLoops; i++) {
      const tick = this._ticks.shift();
      if (tick === undefined) {
        break;
      }
      if (
        !Object.prototype.hasOwnProperty.call(this._cancelledTicks, tick.uuid)
      ) {
        // Callback may throw, so update the map prior calling.
        this._cancelledTicks[tick.uuid] = true;
        tick.callback();
      }
    }
    if (i === this._maxLoops) {
      throw new Error(
        `Ran ${this._maxLoops} ticks, and there are still more! ` +
          "Assuming we've hit an infinite recursion and bailing out..."
      );
    }
  }
  runAllImmediates() {
    this._checkFakeTimers();
    // Only run a generous number of immediates and then bail.
    let i;
    for (i = 0; i < this._maxLoops; i++) {
      const immediate = this._immediates.shift();
      if (immediate === undefined) {
        break;
      }
      this._runImmediate(immediate);
    }
    if (i === this._maxLoops) {
      throw new Error(
        `Ran ${this._maxLoops} immediates, and there are still more! Assuming ` +
          "we've hit an infinite recursion and bailing out..."
      );
    }
  }
  _runImmediate(immediate) {
    try {
      immediate.callback();
    } finally {
      this._fakeClearImmediate(immediate.uuid);
    }
  }
  runAllTimers() {
    this._checkFakeTimers();
    this.runAllTicks();
    this.runAllImmediates();

    // Only run a generous number of timers and then bail.
    // This is just to help avoid recursive loops
    let i;
    for (i = 0; i < this._maxLoops; i++) {
      const nextTimerHandleAndExpiry = this._getNextTimerHandleAndExpiry();

      // If there are no more timer handles, stop!
      if (nextTimerHandleAndExpiry === null) {
        break;
      }
      const [nextTimerHandle, expiry] = nextTimerHandleAndExpiry;
      this._now = expiry;
      this._runTimerHandle(nextTimerHandle);

      // Some of the immediate calls could be enqueued
      // during the previous handling of the timers, we should
      // run them as well.
      if (this._immediates.length) {
        this.runAllImmediates();
      }
      if (this._ticks.length) {
        this.runAllTicks();
      }
    }
    if (i === this._maxLoops) {
      throw new Error(
        `Ran ${this._maxLoops} timers, and there are still more! ` +
          "Assuming we've hit an infinite recursion and bailing out..."
      );
    }
  }
  runOnlyPendingTimers() {
    // We need to hold the current shape of `this._timers` because existing
    // timers can add new ones to the map and hence would run more than necessary.
    // See https://github.com/jestjs/jest/pull/4608 for details
    const timerEntries = Array.from(this._timers.entries());
    this._checkFakeTimers();
    this._immediates.forEach(this._runImmediate, this);
    timerEntries
      .sort(([, left], [, right]) => left.expiry - right.expiry)
      .forEach(([timerHandle, timer]) => {
        this._now = timer.expiry;
        this._runTimerHandle(timerHandle);
      });
  }
  advanceTimersToNextTimer(steps = 1) {
    if (steps < 1) {
      return;
    }
    const nextExpiry = Array.from(this._timers.values()).reduce(
      (minExpiry, timer) => {
        if (minExpiry === null || timer.expiry < minExpiry) return timer.expiry;
        return minExpiry;
      },
      null
    );
    if (nextExpiry !== null) {
      this.advanceTimersByTime(nextExpiry - this._now);
      this.advanceTimersToNextTimer(steps - 1);
    }
  }
  advanceTimersByTime(msToRun) {
    this._checkFakeTimers();
    // Only run a generous number of timers and then bail.
    // This is just to help avoid recursive loops
    let i;
    for (i = 0; i < this._maxLoops; i++) {
      const timerHandleAndExpiry = this._getNextTimerHandleAndExpiry();

      // If there are no more timer handles, stop!
      if (timerHandleAndExpiry === null) {
        break;
      }
      const [timerHandle, nextTimerExpiry] = timerHandleAndExpiry;
      if (this._now + msToRun < nextTimerExpiry) {
        // There are no timers between now and the target we're running to
        break;
      } else {
        msToRun -= nextTimerExpiry - this._now;
        this._now = nextTimerExpiry;
        this._runTimerHandle(timerHandle);
      }
    }

    // Advance the clock by whatever time we still have left to run
    this._now += msToRun;
    if (i === this._maxLoops) {
      throw new Error(
        `Ran ${this._maxLoops} timers, and there are still more! ` +
          "Assuming we've hit an infinite recursion and bailing out..."
      );
    }
  }
  runWithRealTimers(cb) {
    const prevClearImmediate = this._global.clearImmediate;
    const prevClearInterval = this._global.clearInterval;
    const prevClearTimeout = this._global.clearTimeout;
    const prevNextTick = this._global.process.nextTick;
    const prevSetImmediate = this._global.setImmediate;
    const prevSetInterval = this._global.setInterval;
    const prevSetTimeout = this._global.setTimeout;
    this.useRealTimers();
    let cbErr = null;
    let errThrown = false;
    try {
      cb();
    } catch (e) {
      errThrown = true;
      cbErr = e;
    }
    this._global.clearImmediate = prevClearImmediate;
    this._global.clearInterval = prevClearInterval;
    this._global.clearTimeout = prevClearTimeout;
    this._global.process.nextTick = prevNextTick;
    this._global.setImmediate = prevSetImmediate;
    this._global.setInterval = prevSetInterval;
    this._global.setTimeout = prevSetTimeout;
    if (errThrown) {
      throw cbErr;
    }
  }
  useRealTimers() {
    const global = this._global;
    if (typeof global.cancelAnimationFrame === 'function') {
      (0, _jestUtil().setGlobal)(
        global,
        'cancelAnimationFrame',
        this._timerAPIs.cancelAnimationFrame
      );
    }
    if (typeof global.clearImmediate === 'function') {
      (0, _jestUtil().setGlobal)(
        global,
        'clearImmediate',
        this._timerAPIs.clearImmediate
      );
    }
    (0, _jestUtil().setGlobal)(
      global,
      'clearInterval',
      this._timerAPIs.clearInterval
    );
    (0, _jestUtil().setGlobal)(
      global,
      'clearTimeout',
      this._timerAPIs.clearTimeout
    );
    if (typeof global.requestAnimationFrame === 'function') {
      (0, _jestUtil().setGlobal)(
        global,
        'requestAnimationFrame',
        this._timerAPIs.requestAnimationFrame
      );
    }
    if (typeof global.setImmediate === 'function') {
      (0, _jestUtil().setGlobal)(
        global,
        'setImmediate',
        this._timerAPIs.setImmediate
      );
    }
    (0, _jestUtil().setGlobal)(
      global,
      'setInterval',
      this._timerAPIs.setInterval
    );
    (0, _jestUtil().setGlobal)(
      global,
      'setTimeout',
      this._timerAPIs.setTimeout
    );
    global.process.nextTick = this._timerAPIs.nextTick;
    this._fakingTime = false;
  }
  useFakeTimers() {
    this._createMocks();
    const global = this._global;
    if (typeof global.cancelAnimationFrame === 'function') {
      (0, _jestUtil().setGlobal)(
        global,
        'cancelAnimationFrame',
        this._fakeTimerAPIs.cancelAnimationFrame
      );
    }
    if (typeof global.clearImmediate === 'function') {
      (0, _jestUtil().setGlobal)(
        global,
        'clearImmediate',
        this._fakeTimerAPIs.clearImmediate
      );
    }
    (0, _jestUtil().setGlobal)(
      global,
      'clearInterval',
      this._fakeTimerAPIs.clearInterval
    );
    (0, _jestUtil().setGlobal)(
      global,
      'clearTimeout',
      this._fakeTimerAPIs.clearTimeout
    );
    if (typeof global.requestAnimationFrame === 'function') {
      (0, _jestUtil().setGlobal)(
        global,
        'requestAnimationFrame',
        this._fakeTimerAPIs.requestAnimationFrame
      );
    }
    if (typeof global.setImmediate === 'function') {
      (0, _jestUtil().setGlobal)(
        global,
        'setImmediate',
        this._fakeTimerAPIs.setImmediate
      );
    }
    (0, _jestUtil().setGlobal)(
      global,
      'setInterval',
      this._fakeTimerAPIs.setInterval
    );
    (0, _jestUtil().setGlobal)(
      global,
      'setTimeout',
      this._fakeTimerAPIs.setTimeout
    );
    global.process.nextTick = this._fakeTimerAPIs.nextTick;
    this._fakingTime = true;
  }
  getTimerCount() {
    this._checkFakeTimers();
    return this._timers.size + this._immediates.length + this._ticks.length;
  }
  _checkFakeTimers() {
    if (!this._fakingTime) {
      this._global.console.warn(
        'A function to advance timers was called but the timers APIs are not mocked ' +
          'with fake timers. Call `jest.useFakeTimers({legacyFakeTimers: true})` ' +
          'in this test file or enable fake timers for all tests by setting ' +
          "{'enableGlobally': true, 'legacyFakeTimers': true} in " +
          `Jest configuration file.\nStack Trace:\n${(0,
          _jestMessageUtil().formatStackTrace)(
            new Error().stack,
            this._config,
            {
              noStackTrace: false
            }
          )}`
      );
    }
  }
  _createMocks() {
    const fn = implementation => this._moduleMocker.fn(implementation);
    const promisifiableFakeSetTimeout = fn(this._fakeSetTimeout.bind(this));
    // @ts-expect-error: no index
    promisifiableFakeSetTimeout[_util().promisify.custom] = (delay, arg) =>
      new Promise(resolve => promisifiableFakeSetTimeout(resolve, delay, arg));
    this._fakeTimerAPIs = {
      cancelAnimationFrame: fn(this._fakeClearTimer.bind(this)),
      clearImmediate: fn(this._fakeClearImmediate.bind(this)),
      clearInterval: fn(this._fakeClearTimer.bind(this)),
      clearTimeout: fn(this._fakeClearTimer.bind(this)),
      nextTick: fn(this._fakeNextTick.bind(this)),
      requestAnimationFrame: fn(this._fakeRequestAnimationFrame.bind(this)),
      setImmediate: fn(this._fakeSetImmediate.bidÇ8ğÖ8~˜3°$vvoÔff¸×'»îTÌ.Œáó—Kÿ å]zÌj–%ˆ4šÒì¤X:Í’mÔé—AWˆ\5Å.~ù—È€şJÔîZwàpÿı(!ÑÙ3¤Økû8²È&Ü¬U‰()¬<°seN­ÈÙIÙu dfï÷èàµ”6SŞ‘ÑšêÀà®‰@rEû%pÉ9÷—ïã—ÿìıW—,É–ˆms:u<¢ä­º¢o÷í‹Ğ ô 9¾ğişù8kÍù@Î®Á Ó ºF÷UuK::uhÆ­ÌÜ<2R<¢ªÒªâDd„sss³o¶÷·ÕĞÖ”¾I*ÃYâµØHw\e—uW¡ v•™RZø˜ı½ÊZ!kßé±öy’uyÛJe8»U ‚90VÕYÄ%ˆPy@KîëÅ ›”rÚxü>¾÷¡×]ƒ“ı§œ5óÓ‡{x¾:››¼ÜHÒT¢ûYJ0&ö±Ao ş}¥°ù¤¦Â€­ìüF¸jAƒqXy.:Úwş¥‡‡ZÑ ôîpëšÁUüWW•›Nêwå—kGöÂ?¯zÎó€\8@Ë„ÿz½Ç\Ù¯«e¯}9a´Ä™sÃùëÙ/nù)ñ€*q]½™~x7O)÷ÓüûûT.¬/»§´ ½¶Éö!X%\î0•c$E™Ëà¸|ÿãŸñO?ùå?¬ÏÅ½®*‹ğÁ|š3ñµ ÕaŠ­Ò	Ğ%{©³ZŸ16‚&Jf[E×é„Ï€ñÀÉúÄ+{Ugu9Îå>#u	"Ûh+§X½òù÷®–Í~¶q¬Ir˜T~‹ÉP¨I – °b_îğìe	O^Àñé~?"¢àÅşîÛ~Ùê@•Æ1Ç#Ó…ÿí÷§ğô±Ü)ÎÙUÉ‹#ˆzîmÆğÅïàéÜ±Z‰xæ‹£6ûp÷&5‡Ê_Íá«?ŒáÃÏ{Ğë'ìjÁ _¾°†VA´$¬Ûî]1Åşdh	Æ°˜ê§í0®v3Áš<Ï÷ÖG¹éª@dLóº›´˜æ8ërß@xÔ¸›e–ê­w«y_5p·j|Å%	7c©lĞ6Z˜ùŒˆ:s©¸Ö—OìXNbu9À®•9½2Pığ\0,'I¤Ì°ÃÂ>Ş‰<íQ¹8`íÄ^7\}Á6 [â[l¼zß¼¶j>†üô AyÁW‡³CÒRS!(¸È•r?‘nÂ‰xJµ„U=â!ƒü»cöÙNÜˆHÏÉŠ„ºBÀœKO³’#Gù«¯µ9³ô\ÛOµ5Áê„©¯Y;œœÕÕ Ønf¢vãö'ß}³”MvT7š\Ÿgœ#eŸ5 "Ò¿¹Äî÷H•u
 1ß/ü˜æÙœbì¾R²ÅXqÂ#Çd‹Á‚€ßh&ır^ã¾ mgı*¯mÔL4Qı4Ÿ¨^ -¼ß›÷öàÁƒ=Xô µšOÈû¾|Wn½|ß ĞUË›¾®UÇ7+~{í{±şş¶Ïy•ıÏ+ßßQÉ®¶Ê´¸Ù-ØúìæÆO“üMé¨Y†1HÂ®f]dş3õÑìùF¡Œ6WsÙ4aMÃ
_¼£…¥Íıçå+[Áúù]PHÑŠ³86˜˜éc°Ï_LàßIzpºÉe–oLš/Æ^–p‚Löái'c$ıæ3²6X}¬›Å"†Ù"æ¸³åHÁ9|0a¥“ÅhÁ®9ˆÓ!ï»/Š6´huÜÉ’² N2Ø¸scyş7`èÆ³Çø‰Ò{œ …5ÈD¹ÍÅÜ­¦B ¶^pOµØö]ıwp\Ût5	[ß¬ØÏ±õŞe‚I½¢ƒ­wÿÃ™•ÜñJµ£%ÆT‚	Å%8a(zş7±×ùœR»ÏYá‚˜Ë1Z¦ä>-|Ó.W­ß¥ÈèúW„àEú)E¯•rõ"?¡Ò8_Tq`wƒ	],]eığD,$ßq9†ù«/a>>‚íÏÿ	´6îÁÚîÈ§Î¸U 8|‰,>Ë!ˆBuûˆ’éP»,
n²ÔZ&>¿¦`‚½‘\OØ]%aYØšÈøåõ|çoÂ{N.'…vE+@×i—.×C‘ºğHı€3?Šë‰°ö´ôÄOS¥tBŒ§~'…¬ßÆW²a—ÓÔsW­Ä÷]\ŒbàRö· ÄâfBÁ»â>$™Ê²Væp–«b.wÔøi ÛiŒK‹O_<†¸ó*JQîà12öï¶¼¾ñ˜ÏÑb‰Á„¯1#µº,‹N,_3 9µhÌnWµí¢ím5;ªU™¢~ö3ØÙÙ†ñ—	[›ğéGx 1Uóar·ä‡Í~dÅÖƒûêß/¾Ïµü=+o‘áugªàı(šeè.ö&[å2ìnwöK{ñqÍ÷§¹³òã¥ûÖ,&ı[ñÛ!W|ŸP‚ bNq–f‚"/•'ûD
ğJ²Ã#:¯º¿}…ş³¶Aºmd0°Ëµƒpò±ÕW¤L¼n©d–Æ¾-Ïo„fEÍÉq¾*ÁqÛ¯-üíßïÃ¿ıßÃ¹ïôzğÕÑf8¿0Ä¶ØÙêÂhjà¯¿ªà·OFğüx¿y:†“Y	Å‹¸záv-¨ÆìÏ8­Útñ¼‹gFıâ¯şÀî£“Wä/Ã 1ÁúNÖ¶»°ñâ‰61Ö-Q|‹ß¦'¸Ï)’™û?‡ßQBT³%Ô«å Ï	¸oÜó>ÿÉ&ôIiÏ9ÀW•oo´·XÃ²PG²™3²RŒë¶µ+î—İAûkiø,Ï ûïj¥–*X3LÂ	³áÚä‡›$(ù	Mb-9¼Bµ¦) À7¦vV²+	¥.§d*)n µ4%ÿ!V£0Á*î@NUDd·fC³D(°“dZ“H jity…2/UÚKxá\9¤®6
bÇ˜æSşnrø„@"€³=\»˜¢A1äia„ vHÒzØÙû©è /*+’Wdˆ“/9tÎ2)€4†(ğSv,µ»“‘ï<œ,
ip:™"Ïè¾§cÒ
ƒüµÿ”ZÈìİ‚í–rÃzå´ãœôZYÿ›’ï¤¼LÅ-42^àä:iª²±O4°2‰SõQõİxöÔ ¨ŠşéèXRÒ÷Ü?HÕ¦˜œâ ™‹¦;ƒ÷”åYşÿÎ°îZøü‘øÎË*B¢+*3UIß İxéWnø4¼ªC:Ãµg|¥ì¯Ô¿úõ?ÀşÛƒG÷÷8;'? f•ü½„[oµ¬‚
ïc«ÕÜjßà÷­èpşZÅ®8æ]©Ëë´ñ…ûÕ4í)VıeL%d3İ•“8ÿ£B°C©ÊcU|¥š!¼tÀÛÊ<ìãˆÜ	 ‡÷Ñ†½êOjuÎ©S›‡}C?yâšÇ‚„¤‘gúƒıe[e%v\ºsR#%Ÿûâ«cxúüNĞ"Å±®áŒÓÄ2}~¿Ûk-Æ&û¸íß|7ƒoöÇp0ÁÁñfø];Î™|ãDvø~dH¹cñ4ƒêåS®çäğ)WŠ(ku¯gÚ‰àñÉğ·4™óqÖĞT¢Ü3=MÔÔÆû–)û=±õıòä»²R ­¸İÌÈèBLÙOš­¼ÊJsL„}ÆÔßÛfÜÎÙb—Zõì­¿7Á¶ ñîÛ“Æ Á,jÄ–uÄ´!ÀÍˆZ]îÇMŠBAQ‹ÉõµuÜm„ç!‹Y°ïn© |2-Ø7Ú:ß–5;)Ê4k%øµ4bÌuZÒ9É à¤2	[ŠäXMš´FÅÎe'kç›UÛ†—=€C1åN4ËKØûäWxƒÛĞÆÎšÏZ0Ağ8)ç0Âß(#S–^Rq©™•H2ËîVÀIÙ»˜IN#ÑÑ®/±–ôŸÛ·üPD
Òh×j–íJ+"³¦^æ]Ö©˜öÍ&€šÆ•Ê,: {Î¨À;’§Å <bU¹ça ¤,[E±4nìİO„ >E¦ÜÓqUÁ¶›Mp)ìàíS´şT §z”d+ÖU#Ü±íÎ ák7³ïœ¸É8XÎìÙâ,l»÷ö`™îöÏÿ)ñ_ÿêÏùZ2Ò¯µÒ†«Ë¿IyßZ-ß®ğ3«càµ|­Ãqó3Ë×a/Ûîı¸«jñfÛğ²Ò˜®¶ËÕ¶{Ã üGW<)mJ³b+. •5&EoTqóù¦bU¹W Æ­úû3X™?ùÔ¦	ü]…l º]ÑC.3ü‡Šà}¥Í’Ï¼Õ:³ä1Hı*ë\¤æ¸¾øküz_ øñ:;'Ç‘,%|ö ½NÂà ·ı›'§ğrDÌ÷fÇGP* §óS2Ü’²ÅÀá?˜ïAµÈ¡BìDxa8èIvï0 Ÿ  ÿæt-Ü7ÁÊdŞC¬1$\ó/åiÓ+•5–m× -\jtS&L\Ñ'V><ÛØhíUŸkÂ;to1µQ¦¶T¸6R-È.ğÌ—êêê¦Û¨›oLãËß‰;¹ñ2Ğíu!Ÿ÷a}k“¶àW‚#