{"version":3,"names":["Buffer","constructor","map","indentChar","_map","_buf","_str","_appendCount","_last","_queue","_queueCursor","_canMarkIdName","_indentChar","_fastIndentations","_position","line","column","_sourcePosition","identifierName","undefined","identifierNamePos","filename","i","push","repeat","_allocQueue","queue","char","_pushQueue","cursor","length","item","_popQueue","Error","get","_flush","result","code","trimRight","decodedMap","getDecoded","__mergedMap","resultMap","value","Object","defineProperty","writable","rawMappings","mappings","getRawMappings","append","str","maybeNewline","_append","appendChar","_appendChar","sourcePosition","queueIndentation","queueCursor","sourcePos","fastIndentation","String","fromCharCode","_mark","len","position","charCodeAt","indexOf","last","_this$_map","mark","removeTrailingNewline","removeLastSemicolon","getLastChar","getNewlineCount","count","endsWithCharAndNewline","lastCp","hasContent","exactSource","loc","cb","source","prop","_normalizePosition","sourceWithOffset","columnOffset","pos","target","Math","max","getCurrentColumn","lastIndex","getCurrentLine","exports","default"],"sources":["../src/buffer.ts"],"sourcesContent":["import type SourceMap from \"./source-map.ts\";\n\n// We inline this package\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as charcodes from \"charcodes\";\n\nexport type Pos = {\n  line: number;\n  column: number;\n  index: number;\n};\nexport type Loc = {\n  start?: Pos;\n  end?: Pos;\n  filename?: string;\n};\ntype SourcePos = {\n  line: number | undefined;\n  column: number | undefined;\n  identifierName: string | undefined;\n  filename: string | undefined;\n};\ntype InternalSourcePos = SourcePos & { identifierNamePos: Pos | undefined };\n\ntype QueueItem = {\n  char: number;\n  repeat: number;\n  line: number | undefined;\n  column: number | undefined;\n  identifierName: undefined; // Not used, it always undefined.\n  identifierNamePos: undefined; // Not used, it always undefined.\n  filename: string | undefined;\n};\n\nexport default class Buffer {\n  constructor(map: SourceMap | null, indentChar: string) {\n    this._map = map;\n    this._indentChar = indentChar;\n\n    for (let i = 0; i < 64; i++) {\n      this._fastIndentations.push(indentChar.repeat(i));\n    }\n\n    this._allocQueue();\n  }\n\n  _map: SourceMap | null = null;\n  _buf = \"\";\n  _str = \"\";\n  _appendCount = 0;\n  _last = 0;\n  _queue: QueueItem[] = [];\n  _queueCursor = 0;\n  _canMarkIdName = true;\n  _indentChar = \"\";\n  _fastIndentations: string[] = [];\n\n  _position = {\n    line: 1,\n    column: 0,\n  };\n  _sourcePosition: InternalSourcePos = {\n    identifierName: undefined,\n    identifierNamePos: undefined,\n    line: undefined,\n    column: undefined,\n    filename: undefined,\n  };\n\n  _allocQueue() {\n    const queue = this._queue;\n\n    for (let i = 0; i < 16; i++) {\n      queue.push({\n        char: 0,\n        repeat: 1,\n        line: undefined,\n        column: undefined,\n        identifierName: undefined,\n        identifierNamePos: undefined,\n        filename: \"\",\n      });\n    }\n  }\n\n  _pushQueue(\n    char: number,\n    repeat: number,\n    line: number | undefined,\n    column: number | undefined,\n    filename: string | undefined,\n  ) {\n    const cursor = this._queueCursor;\n    if (cursor === this._queue.length) {\n      this._allocQueue();\n    }\n    const item = this._queue[cursor];\n    item.char = char;\n    item.repeat = repeat;\n    item.line = line;\n    item.column = column;\n    item.filename = filename;\n\n    this._queueCursor++;\n  }\n\n  _popQueue(): QueueItem {\n    if (this._queueCursor === 0) {\n      throw new Error(\"Cannot pop from empty queue\");\n    }\n    return this._queue[--this._queueCursor];\n  }\n\n  /**\n   * Get the final string output from the buffer, along with the sourcemap if one exists.\n   */\n\n  get() {\n    this._flush();\n\n    const map = this._map;\n    const result = {\n      // Whatever trim is used here should not execute a regex against the\n      // source string since it may be arbitrarily large after all transformations\n      code: (this._buf + this._str).trimRight(),\n      // Decoded sourcemap is free to generate.\n      decodedMap: map?.getDecoded(),\n      // Used as a marker for backwards compatibility. We moved input map merging\n      // into the generator. We cannot merge the input map a second time, so the\n      // presence of this field tells us we've already done the work.\n      get __mergedMap() {\n        return this.map;\n      },\n      // Encoding the sourcemap is moderately CPU expensive.\n      get map() {\n        const resultMap = map ? map.get() : null;\n        result.map = resultMap;\n        return resultMap;\n      },\n      set map(value) {\n        Object.defineProperty(result, \"map\", { value, writable: true });\n      },\n      // Retrieving the raw mappings is very memory intensive.\n      get rawMappings() {\n        const mappings = map?.getRawMappings();\n        result.rawMappings = mappings;\n        return mappings;\n      },\n      set rawMappings(value) {\n        Object.defineProperty(result, \"rawMappings\", { value, writable: true });\n      },\n    };\n\n    return result;\n  }\n\n  /**\n   * Add a string to the buffer that cannot be reverted.\n   */\n\n  append(str: string, maybeNewline: boolean): void {\n    this._flush();\n\n    this._append(str, this._sourcePosition, maybeNewline);\n  }\n\n  appendChar(char: number): void {\n    this._flush();\n    this._appendChar(char, 1, this._sourcePosition);\n  }\n\n  /**\n   * Add a string to the buffer than can be reverted.\n   */\n  queue(char: number): void {\n    // Drop trailing spaces when a newline is inserted.\n    if (char === charcodes.lineFeed) {\n      while (this._queueCursor !== 0) {\n        const char = this._queue[this._queueCursor - 1].char;\n        if (char !== charcodes.space && char !== charcodes.tab) {\n          break;\n        }\n\n        this._queueCursor--;\n      }\n    }\n\n    const sourcePosition = this._sourcePosition;\n    this._pushQueue(\n      char,\n      1,\n      sourcePosition.line,\n      sourcePosition.column,\n      sourcePosition.filename,\n    );\n  }\n\n  /**\n   * Same as queue, but this indentation will never have a sourcemap marker.\n   */\n  queueIndentation(repeat: number): void {\n    if (repeat === 0) return;\n    this._pushQueue(-1, repeat, undefined, undefined, undefined);\n  }\n\n  _flush(): void {\n    const queueCursor = this._queueCursor;\n    const queue = this._queue;\n    for (let i = 0; i < queueCursor; i++) {\n      const item: QueueItem = queue[i];\n      this._appendChar(item.char, item.repeat, item);\n    }\n    this._queueCursor = 0;\n  }\n\n  _appendChar(\n    char: number,\n    repeat: number,\n    sourcePos: InternalSourcePos,\n  ): void {\n    this._last = char;\n\n    if (char === -1) {\n      const fastIndentation = this._fastIndentations[repeat];\n      if (fastIndentation !== undefined) {\n        this._str += fastIndentation;\n      } else {\n        this._str +=\n          repeat > 1 ? this._indentChar.repeat(repeat) : this._indentChar;\n      }\n    } else {\n      this._str +=\n        repeat > 1\n          ? String.fromCharCode(char).repeat(repeat)\n          : String.fromCharCode(char);\n    }\n\n    if (char !== charcodes.lineFeed) {\n      this._mark(\n        sourcePos.line,\n        sourcePos.column,\n        sourcePos.identifierName,\n        sourcePos.identifierNamePos,\n        sourcePos.filename,\n      );\n      this._position.column += repeat;\n    } else {\n      this._position.line++;\n      this._position.column = 0;\n    }\n\n    if (this._canMarkIdName) {\n      sourcePos.identifierName = undefined;\n      sourcePos.identifierNamePos = undefined;\n    }\n  }\n\n  _append(\n    str: string,\n    sourcePos: InternalSourcePos,\n    maybeNewline: boolean,\n  ): void {\n    const len = str.length;\n    const position = this._position;\n\n    this._last = str.charCodeAt(len - 1);\n\n    if (++this._appendCount > 4096) {\n      // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n      +this._str; // Unexplainable huge performance boost. Ref: https://github.com/davidmarkclements/flatstr License: MIT\n      this._buf += this._str;\n      this._str = str;\n      this._appendCount = 0;\n    } else {\n      this._str += str;\n    }\n\n    if (!maybeNewline && !this._map) {\n      position.column += len;\n      return;\n    }\n\n    const { column, identifierName, identifierNamePos, filename } = sourcePos;\n    let line = sourcePos.line;\n\n    if (\n      (identifierName != null || identifierNamePos != null) &&\n      this._canMarkIdName\n    ) {\n      sourcePos.identifierName = undefined;\n      sourcePos.identifierNamePos = undefined;\n    }\n\n    // Search for newline chars. We search only for `\\n`, since both `\\r` and\n    // `\\r\\n` are normalized to `\\n` during parse. We exclude `\\u2028` and\n    // `\\u2029` for performance reasons, they're so uncommon that it's probably\n    // ok. It's also unclear how other sourcemap utilities handle them...\n    let i = str.indexOf(\"\\n\");\n    let last = 0;\n\n    // If the string starts with a newline char, then adding a mark is redundant.\n    // This catches both \"no newlines\" and \"newline after several chars\".\n    if (i !== 0) {\n      this._mark(line, column, identifierName, identifierNamePos, filename);\n    }\n\n    // Now, find each remaining newline char in the string.\n    while (i !== -1) {\n      position.line++;\n      position.column = 0;\n      last = i + 1;\n\n      // We mark the start of each line, which happens directly after this newline char\n      // unless this is the last char.\n      // When manually adding multi-line content (such as a comment), `line` will be `undefined`.\n      if (last < len && line !== undefined) {\n        this._mark(++line, 0, undefined, undefined, filename);\n      }\n      i = str.indexOf(\"\\n\", last);\n    }\n    position.column += len - last;\n  }\n\n  _mark(\n    line: number | undefined,\n    column: number | undefined,\n    identifierName: string | undefined,\n    identifierNamePos: Pos | undefined,\n    filename: string | undefined,\n  ): void {\n    this._map?.mark(\n      this._position,\n      line,\n      column,\n      identifierName,\n      identifierNamePos,\n      filename,\n    );\n  }\n\n  removeTrailingNewline(): void {\n    const queueCursor = this._queueCursor;\n    if (\n      queueCursor !== 0 &&\n      this._queue[queueCursor - 1].char === charcodes.lineFeed\n    ) {\n      this._queueCursor--;\n    }\n  }\n\n  removeLastSemicolon(): void {\n    const queueCursor = this._queueCursor;\n    if (\n      queueCursor !== 0 &&\n      this._queue[queueCursor - 1].char === charcodes.semicolon\n    ) {\n      this._queueCursor--;\n    }\n  }\n\n  getLastChar(): number {\n    const queueCursor = this._queueCursor;\n    return queueCursor !== 0 ? this._queue[queueCursor - 1].char : this._last;\n  }\n\n  /**\n   * This will only detect at most 1 newline after a call to `flush()`,\n   * but this has not been found so far, and an accurate count can be achieved if needed later.\n   */\n  getNewlineCount(): number {\n    const queueCursor = this._queueCursor;\n    let count = 0;\n    if (queueCursor === 0) return this._last === charcodes.lineFeed ? 1 : 0;\n    for (let i = queueCursor - 1; i >= 0; i--) {\n      if (this._queue[i].char !== charcodes.lineFeed) {\n        break;\n      }\n      count++;\n    }\n    return count === queueCursor && this._last === charcodes.lineFeed\n      ? count + 1\n      : count;\n  }\n\n  /**\n   * check if current _last + queue ends with newline, return the character before newline\n   */\n  endsWithCharAndNewline(): number | undefined {\n    const queue = this._queue;\n    const queueCursor = this._queueCursor;\n    if (queueCursor !== 0) {\n      // every element in queue is one-length whitespace string\n      const lastCp = queue[queueCursor - 1].char;\n      if (lastCp !== charcodes.lineFeed) return;\n      if (queueCursor > 1) {\n        return queue[queueCursor - 2].char;\n      } else {\n        return this._last;\n      }\n    }\n    // We assume that everything being matched is at most a single token plus some whitespace,\n    // which everything currently is, but otherwise we'd have to expand _last or check _buf.\n  }\n\n  hasContent(): boolean {\n    return this._queueCursor !== 0 || !!this._last;\n  }\n\n  /**\n   * Certain sourcemap usecases expect mappings to be more accurate than\n   * Babel's generic sourcemap handling allows. For now, we special-case\n   * identifiers to allow for the primary cases to work.\n   * The goal of this line is to ensure that the map output from Babel will\n   * have an exact range on identifiers in the output code. Without this\n   * line, Babel would potentially include some number of trailing tokens\n   * that are printed after the identifier, but before another location has\n   * been assigned.\n   * This allows tooling like Rollup and Webpack to more accurately perform\n   * their own transformations. Most importantly, this allows the import/export\n   * transformations performed by those tools to loose less information when\n   * applying their own transformations on top of the code and map results\n   * generated by Babel itself.\n   *\n   * The primary example of this is the snippet:\n   *\n   *   import mod from \"mod\";\n   *   mod();\n   *\n   * With this line, there will be one mapping range over \"mod\" and another\n   * over \"();\", where previously it would have been a single mapping.\n   */\n  exactSource(loc: Loc, cb: () => void) {\n    if (!this._map) {\n      cb();\n      return;\n    }\n\n    this.source(\"start\", loc);\n    // @ts-expect-error identifierName is not defined\n    const identifierName = loc.identifierName;\n    const sourcePos = this._sourcePosition;\n    if (identifierName) {\n      this._canMarkIdName = false;\n      sourcePos.identifierName = identifierName;\n    }\n    cb();\n\n    if (identifierName) {\n      this._canMarkIdName = true;\n      sourcePos.identifierName = undefined;\n      sourcePos.identifierNamePos = undefined;\n    }\n    this.source(\"end\", loc);\n  }\n\n  /**\n   * Sets a given position as the current source location so generated code after this call\n   * will be given this position in the sourcemap.\n   */\n\n  source(prop: \"start\" | \"end\", loc: Loc): void {\n    if (!this._map) return;\n\n    // Since this is called extremely often, we reuse the same _sourcePosition\n    // object for the whole lifetime of the buffer.\n    this._normalizePosition(prop, loc, 0);\n  }\n\n  sourceWithOffset(\n    prop: \"start\" | \"end\",\n    loc: Loc,\n    columnOffset: number,\n  ): void {\n    if (!this._map) return;\n\n    this._normalizePosition(prop, loc, columnOffset);\n  }\n\n  _normalizePosition(prop: \"start\" | \"end\", loc: Loc, columnOffset: number) {\n    const pos = loc[prop];\n    const target = this._sourcePosition;\n\n    if (pos) {\n      target.line = pos.line;\n      // TODO: Fix https://github.com/babel/babel/issues/15712 in downstream\n      target.column = Math.max(pos.column + columnOffset, 0);\n      target.filename = loc.filename;\n    }\n  }\n\n  getCurrentColumn(): number {\n    const queue = this._queue;\n    const queueCursor = this._queueCursor;\n\n    let lastIndex = -1;\n    let len = 0;\n    for (let i = 0; i < queueCursor; i++) {\n      const item = queue[i];\n      if (item.char === charcodes.lineFeed) {\n        lastIndex = len;\n      }\n      len += item.repeat;\n    }\n\n    return lastIndex === -1 ? this._position.column + len : len - 1 - lastIndex;\n  }\n\n  getCurrentLine(): number {\n    let count = 0;\n\n    const queue = this._queue;\n    for (let i = 0; i < this._queueCursor; i++) {\n      if (queue[i].char === charcodes.lineFeed) {\n        count++;\n      }\n    }\n\n    return this._position.line + count;\n  }\n}\n"],"mappings":";;;;;;AAkCe,MAAMA,MAAM,CAAC;EAC1BC,WAAWA,CAACC,GAAqB,EAAEC,UAAkB,EAAE;IAAA,KAWvDC,IAAI,GAAqB,IAAI;IAAA,KAC7BC,IAAI,GAAG,EAAE;IAAA,KACTC,IAAI,GAAG,EAAE;IAAA,KACTC,YAAY,GAAG,CAAC;IAAA,KAChBC,KAAK,GAAG,CAAC;IAAA,KACTC,MAAM,GAAgB,EAAE;IAAA,KACxBC,YAAY,GAAG,CAAC;IAAA,KAChBC,cAAc,GAAG,IAAI;IAAA,KACrBC,WAAW,GAAG,EAAE;IAAA,KAChBC,iBAAiB,GAAa,EAAE;IAAA,KAEhCC,SAAS,GAAG;MACVC,IAAI,EAAE,CAAC;MACPC,MAAM,EAAE;IACV,CAAC;IAAA,KACDC,eAAe,GAAsB;MACnCC,cAAc,EAAEC,SAAS;MACzBC,iBAAiB,EAAED,SAAS;MAC5BJ,IAAI,EAAEI,SAAS;MACfH,MAAM,EAAEG,SAAS;MACjBE,QAAQ,EAAEF;IACZ,CAAC;IA/BC,IAAI,CAACf,IAAI,GAAGF,GAAG;IACf,IAAI,CAACU,WAAW,GAAGT,UAAU;IAE7B,KAAK,IAAImB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,EAAE,EAAEA,CAAC,EAAE,EAAE;MAC3B,IAAI,CAACT,iBAAiB,CAACU,IAAI,CAACpB,UAAU,CAACqB,MAAM,CAACF,CAAC,CAAC,CAAC;IACnD;IAEA,IAAI,CAACG,WAAW,CAAC,CAAC;EACpB;EAyBAA,WAAWA,CAAA,EAAG;IACZ,MAAMC,KAAK,GAAG,IAAI,CAACjB,MAAM;IAEzB,KAAK,IAAIa,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,EAAE,EAAEA,CAAC,EAAE,EAAE;MAC3BI,KAAK,CAACH,IAAI,CAAC;QACTI,IAAI,EAAE,CAAC;QACPH,MAAM,EAAE,CAAC;QACTT,IAAI,EAAEI,SAAS;QACfH,MAAM,EAAEG,SAAS;QACjBD,cAAc,EAAEC,SAAS;QACzBC,iBAAiB,EAAED,SAAS;QAC5BE,QAAQ,EAAE;MACZ,CAAC,CAAC;IACJ;EACF;EAEAO,UAAUA,CACRD,IAAY,EACZH,MAAc,EACdT,IAAwB,EACxBC,MAA0B,EAC1BK,QAA4B,EAC5B;IACA,MAAMQ,MAAM,GAAG,IAAI,CAACnB,YAAY;IAChC,IAAImB,MAAM,KAAK,IAAI,CAACpB,MAAM,CAACqB,MAAM,EAAE;MACjC,IAAI,CAACL,WAAW,CAAC,CAAC;IACpB;IACA,MAAMM,IAAI,GAAG,IAAI,CAACtB,MAAM,CAACoB,MAAM,CAAC;IAChCE,IAAI,CAACJ,IAAI,GAAGA,IAAI;IAChBI,IAAI,CAACP,MAAM,GAAGA,MAAM;IACpBO,IAAI,CAAChB,IAAI,GAAGA,IAAI;IAChBgB,IAAI,CAACf,MAAM,GAAGA,MAAM;IACpBe,IAAI,CAACV,QAAQ,GAAGA,QAAQ;IAExB,IAAI,CAACX,YAAY,EAAE;EACrB;EAEAsB,SAASA,CAAA,EAAc;IACrB,IAAI,IAAI,CAACtB,YAAY,KAAK,CAAC,EAAE;MAC3B,MAAM,IAAIuB,KAAK,CAAC,6BAA6B,CAAC;IAChD;IACA,OAAO,IAAI,CAACxB,MAAM,CAAC,EAAE,IAAI,CAACC,YAAY,CAAC;EACzC;EAMAwB,GAAGA,CAAA,EAAG;IACJ,IAAI,CAACC,MAAM,CAAC,CAAC;IAEb,MAAMjC,GAAG,GAAG,IAAI,CAACE,IAAI;IACrB,MAAMgC,MAAM,GAAG;MAGbC,IAAI,EAAE,CAAC,IAAI,CAAChC,IAAI,GAAG,IAAI,CAACC,IAAI,EAAEgC,SAAS,CAAC,CAAC;MAEzCC,UAAU,EAAErC,GAAG,oBAAHA,GAAG,CAAEsC,UAAU,CAAC,CAAC;MAI7B,IAAIC,WAAWA,CAAA,EAAG;QAChB,OAAO,IAAI,CAACvC,GAAG;MACjB,CAAC;MAED,IAAIA,GAAGA,CAAA,EAAG;QACR,MAAMwC,SAAS,GAAGxC,GAAG,GAAGA,GAAG,CAACgC,GAAG,CAAC,CAAC,GAAG,IAAI;QACxCE,MAAM,CAAClC,GAAG,GAAGwC,SAAS;QACtB,OAAOA,SAAS;MAClB,CAAC;MACD,IAAIxC,GAAGA,CAACyC,KAAK,EAAE;QACbC,MAAM,CAACC,cAAc,CAACT,MAAM,EAAE,KAAK,EAAE;UAAEO,KAAK;UAAEG,QAAQ,EAAE;QAAK,CAAC,CAAC;MACjE,CAAC;MAED,IAAIC,WAAWA,CAAA,EAAG;QAChB,MAAMC,QAAQ,GAAG9C,GAAG,oBAAHA,GAAG,CAAE+C,cAAc,CAAC,CAAC;QACtCb,MAAM,CAACW,WAAW,GAAGC,QAAQ;QAC7B,OAAOA,QAAQ;MACjB,CAAC;MACD,IAAID,WAAWA,CAACJ,KAAK,EAAE;QACrBC,MAAM,CAACC,cAAc,CAACT,MAAM,EAAE,aAAa,EAAE;UAAEO,KAAK;UAAEG,QAAQ,EAAE;QAAK,CAAC,CAAC;MACzE;IACF,CAAC;IAED,OAAOV,MAAM;EACf;EAMAc,MAAMA,CAACC,GAAW,EAAEC,YAAqB,EAAQ;IAC/C,IAAI,CAACjB,MAAM,CAAC,CAAC;IAEb,IAAI,CAACkB,OAAO,CAACF,GAAG,EAAE,IAAI,CAAClC,eAAe,EAAEmC,YAAY,CAAC;EACvD;EAEAE,UAAUA,CAAC3B,IAAY,EAAQ;IAC7B,IAAI,CAACQ,MAAM,CAAC,CAAC;IACb,IAAI,CAACoB,WAAW,CAAC5B,IAAI,EAAE,CAAC,EAAE,IAAI,CAACV,eAAe,CAAC;EACjD;EAKAS,KAAKA,CAACC,IAAY,EAAQ;IAExB,IAAIA,IAAI,OAAuB,EAAE;MAC/B,OAAO,IAAI,CAACjB,YAAY,KAAK,CAAC,EAAE;QAC9B,MAAMiB,IAAI,GAAG,IAAI,CAAClB,MAAM,CAAC,IAAI,CAACC,YAAY,GAAG,CAAC,CAAC,CAACiB,IAAI;QACpD,IAAIA,IAAI,OAAoB,IAAIA,IAAI,MAAkB,EAAE;UACtD;QACF;QAEA,IAAI,CAACjB,YAAY,EAAE;MACrB;IACF;IAEA,MAAM8C,cAAc,GAAG,IAAI,CAACvC,eAAe;IAC3C,IAAI,CAACW,UAAU,CACbD,IAAI,EACJ,CAAC,EACD6B,cAAc,CAACzC,IAAI,EACnByC,cAAc,CAACxC,MAAM,EACrBwC,cAAc,CAACnC,QACjB,CAAC;EACH;EAKAoC,gBAAgBA,CAACjC,MAAc,EAAQ;IACrC,IAAIA,MAAM,KAAK,CAAC,EAAE;IAClB,IAAI,CAACI,UAAU,CAAC,CAAC,CAAC,EAAEJ,MAAM,EAAEL,SAAS,EAAEA,SAAS,EAAEA,SAAS,CAAC;EAC9D;EAEAgB,MAAMA,CAAA,EAAS;IACb,MAAMuB,WAAW,GAAG,IAAI,CAAChD,YAAY;IACrC,MAAMgB,KAAK,GAAG,IAAI,CAACjB,MAAM;IACzB,KAAK,IAAIa,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoC,WAAW,EAAEpC,CAAC,EAAE,EAAE;MACpC,MAAMS,IAAe,GAAGL,KAAK,CAACJ,CAAC,CAAC;MAChC,IAAI,CAACiC,WAAW,CAACxB,IAAI,CAACJ,IAAI,EAAEI,IAAI,CAACP,MAAM,EAAEO,IAAI,CAAC;IAChD;IACA,IAAI,CAACrB,YAAY,GAAG,CAAC;EACvB;EAEA6C,WAAWA,CACT5B,IAAY,EACZH,MAAc,EACdmC,SAA4B,EACtB;IACN,IAAI,CAACnD,KAAK,GAAGmB,IAAI;IAEjB,IAAIA,IAAI,KAAK,CAAC,CAAC,EAAE;MACf,MAAMiC,eAAe,GAAG,IAAI,CAAC/C,iBAAiB,CAACW,MAAM,CAAC;MACtD,IAAIoC,eAAe,KAAKzC,SAAS,EAAE;QACjC,IAAI,CAACb,IAAI,IAAIsD,eAAe;MAC9B,CAAC,MAAM;QACL,IAAI,CAACtD,IAAI,IACPkB,MAAM,GAAG,CAAC,GAAG,IAAI,CAACZ,WAAW,CAACY,MAAM,CAACA,MAAM,CAAC,GAAG,IAAI,CAACZ,WAAW;MACnE;IACF,CAAC,MAAM;MACL,çĞ\jM\ÇìÑÖ«¥1,³”[è¥
bÌ‚dÓ<ªò#Äyºıö ]Šš½d÷£§åù¬Ú¡œ;ßvfZC®¾S×6ï”/÷é.ùf{´…u¤ {Í³2×0ÇP4a&cï&qnŸ] è¸Í0ú|øãVs‚¨mNe»?0ôÓÖ(®Dÿ˜¥³Z‡¦Ïìàfâñ>¥hk×#ø¨‰Át™íÎè#cd®®ô§ÍI¹ú…÷w˜«µã†ƒ*9ê¯¹CW“”´+fkg˜Vçc‚ÃïÒOùŸ¼—ì©i¢Ş®»€oˆ©M;6ºk¾»tŠ@¥ıCj]sÖØ›•·çKÇ\‚;nXãS¡ÖÙÄë 3ÍôIŒ™v¤bRìi…;WP(W5»Ss¶óÂ_®³È	ê»¬¾˜pŸE™?…^Fëj¥Ù˜¡Ÿc€ƒ;È}‘ú0W7J‹-zÁŞÆ½úõRöò|¾ll}Ôd1	ş9‡[ÉgµäÁVm¢çwÇŒÊ1Òs~2©#Î3/¡r¦µëQô=,‘=y¸Kğ«\*ì}ÏVsÉ·Uºée¿‰!:R7
ÊÒ>W	i/ô6>k/£'’š°WÊéT=#½Œğ„‡˜I`EÁEû~
/8¨6Æã{šdø•JˆYëı.FŠ1wˆ¹ËÎ§vµÔ}Ã ÖG—GDÛ„óp¢—0½]ØO±zÉgüÈ$E9·ùì ’“mÚ@XßR›²ÈTªmÆoŸìĞi~c).s®Å­¼˜å.«6Ò²“qrRù4Ã'Š=é<ïÔ:<J¹£å¢*Ã«ùQ²,N„°¨[_´]¡IğËäj‚wN0]ôÁ.‡ŒÕ|¾o°>Ö¡¢q¼¯+úòÙàùtépèzŒÜ£obXNH+S/åGµpb]jH|ŠÔóhJßkÓ‚Õ9Ğµ®b30ß¸DGUÒ½C§8³¬K0±©îSi
«ä+Óß9ºI{›kµÓç3‘æÂeVR'¬ß™z?¼Çcÿ·¦ƒne—išù[°6¨V”}÷qX	»âÕPæ¿xÈ= ˆ~¸¦„Û®n$šÚÖû€ãĞ¬İ®ÇÑ¾§r9åø»êé:ze`îP¦{Pq1o÷ÀÈ pÚ«Ïˆªz£Mpá P(fnHzí¡Ôm[ƒÖWEh?5æ„íGšQ¡)ëÖ¾õ;Í y¥w[!ãbÇüŒµè×jìâ¡¬ÈPŠ @ä%¾AµI[„à`q<‘‘Š«)²s<¿)b©?úc)‹àlïü\~ìªÄ]ÜŸì)¥$¿<S„ß•6·’é …ŸÄçtMô4fÿ ²ïÕƒvššg·Jd~ªãbBÈËz9_È¨)ê·LBª1Vú_t3o†¨ÿu,ÿ±“õ¹’P³ŠĞElÕ>)Ê’¦´Òó¥±b…jºMŠ{½àhLÚ™V>ƒ,Öc¢ùÙf&Ä>¬	øÖkMoOm@c+{âuŒT¬åúC3Ä²Œ«Ä˜§é;#åcÓy FØèØO^ÅñìúÃşĞ‘9YI”º0àß æ	iÙô6Ç¸#½¸–Àfj{Ê¥E#Jœ‰ÈÜjî¦Hm@$ºÕ+Ï‰Ë‚^sA«ÔGK—ï¡M(%—Ø‰!ĞÔ&ñ‡i£Z7\œ¹¤P^×)§³x“á?¢	
-ëvÿ	†ÿF¢vİôGr8­t.¾yœ0`+Èíy^q¸ımmŸÈ©?-^T yƒ½šäRßd}wÂé“fóW6ä¨íãÍ¬½áA—³ç)‘t®£Òë:ØŞºÖr˜UÅ¨Èå0¶ÄÖX›+sX·‡feêñ†SîÜ/ÖcP	SÉA…áòS1;Í³%E2ˆg/ÜÜ]°•c°é@Ä û)w sç*¾Ø¦"‹!>ÁâDXó
Ö«­61#wbàN¸	7Ó"ÕûÑ!÷ ìğ¢°ÁÓÓ‹„ <!~™•q»$LNP%TLö‡4O‹ÊıÁ]ÁAHQ±ÒO’’ïû¬®9äÁ*Ø'Rk[=:æ{Ã6y"´å™_8C˜Cx¾Xş“ÃA0ŞÊÂç³‹|©1ıØ&™¬,è}ü˜ñ•¸¯Ve´Ì¦ª£ùÁÔ‰øv¸3hXñvƒÇÌ8¤ÒÙÈ¢eRãÊH~ğEıN”r>T/NÈ7…^ÑÁûE«î#’×µ'Œ/™¦¥Ò=À}+±Œ†ú»sÒÆL&rÆğfšêBR9ğÖì9Gcf&ƒí®³ {6µ÷T¹Ä¥š¹‚Şa‰‡¡%j¬å)Fc˜0©.³¬ã\åÆï‘óÒ®ó~Ëÿ;Ú	~_MTİÑùbPZ#‡'W2hŞ'l¼õ‹ùŞ>97?²ëĞ¡;zB)Wo’É´ B+)æp«¡¨V)b`)$L heFĞ+k6H‚/_ôëf[ÓÑ+l|~Ş–ü½æi³Ği±çqs¾ê~=ŸøuŞ™ŠuzÜ†D×ëºD€AqtşûM~ìT™fµ9-13ùú’ÎûÆ42gÀ»5³,ÛÉl©9Bà1u¼Ë-óÏ;çmAE¿Ör™º+Ãjåzä¬‘…9Ë¨‹í9!m‡†ïI4:æ8J&™üAÇ4Óåü3Å 5G×İ†v±Y¼ÔÌ˜ºqçëfë +ŸÇø8îî÷ñˆ¾ŠœÙİ¡—jÓj…ôµÍ¤ÏPgÏ‘{&A	ê…&®Æ³Ç;;B2Â.¤ï%ë“µ¨}8‰ÎnÈRÕOgì®§pLÆ‹%Ğ|ŞG/‡—Ğ|Àn0nbJÄ‚¸l¶Q¹ÕÂ¯8¥:ÂQ_&—’'û¸±R”Šµ¢P½l@j‡‘&¢qŸ˜ğú¯â%Ù½ùåùT3Š¢µÙjâë>Ş>	üéêÑëEl|fq„^Â~•]À<'ÑÏã”©à#„İ Úk’¸6Ûı¿ùêNvYŞûßU,’©W÷…Ùåæ™ñm”ÓÂğ˜W¸í%'{ƒ4NGPæ-o.Ë‡—VrÂü™/‡©×¥Hœ6t½™4NÌP½ ›¨€™úá´Ë&^9®tª}O• =U~íoÇñ •«X31r©pÙ”ı»G;&ÑdË!NÈE}D½ÕY7„Ö÷.9}?œø&.µ²FOVq¥o°½ÑÚˆhÑáÌÊZ-¥vx…®yÜŠÈ^iÛêÜâœ8Õ·QµHhµXÁ›Ü(šƒQ“²¤céF‚”>ç4¬š¤ZùB×„		Áƒ©"-¡qAòÂWºü}Ñù
ı¥ym±+„ÿ­„!Ôö±ÿñ¯Â@xÂ6å«ù[”‹t£™°´åQÕĞ__¹–\s´P¼ĞjiCÕv½XBV—û\v›0Û×à}1­=¼kyÚ÷./ÖSuó‹£Soˆ^©÷½ÓÍ·x´½¢ŞxŞJ»½·¿k|óuúF4Z. 6/iŞt™ÉªÇT´
Cê5YIÉÈ—Ds¿‚Hß¾çß¨±¤É3ªiy¤²È¶dYÂkìs `÷œsHş##ñó3 aš,T|"·[»RMOQ•ßX¯HàXb™$Z¯áO‡ìÖûÁÖÖ†j¡›ê*l?b¸ÀçoÃÊ9•zn&úT«Ôí¨ºçjïù¶	Ñ:t/Û“X2Ç°4ü7³î¶•·J6Ü{}QŸ…ù )/}.F¢íÉ§ë%³©7…h`\øÓwJNÙt‚¤!c¤ÒEô#·E¤æÜ¡éõ[½‡-J€«yÎ€ËÀ«ûÉÁæ?`9i×›ôL³{¦3U2ïW§İp„º`1ğsE6]ğåØöÌ¡Ú‹ºŞ=¨CÓYÛ›òjƒ4­\Ó&WJÚ¿ZÔ¸HógQ|7ª˜ôÈ1ºll‰Ñ·w$‚ò0İ’)/¥8ìD†Ùm2€<á2"^Qö hñäX´G¥öƒñÖ_æ¶p¯¬Mñ±+ŸŒ_Ñ¥ÏŒ=TèÁ¯:U$4qUğfõ‘?+o©DÛ¢†Â!­åæ7V>nch”}·/8œÖÏ]E_÷«ÉSBk:è›ÆÕé³g;W±6Nó*\ŸÎ…Ø¯<ÈŠøE³ áF:¿‚Õ®>»& ¸`W·O›Ó:tsGxfõW¥ÓÈÁ3ø_F&v…‰ê+uDöå~­’ï1Dü,Vùlt‡|FmN~.¦¶/"/½`7WeÉ¹¶q&dzXÿŠld¶%â;S´Ûr‘p•nıgó`†ãŠ	sş
a˜ÂM
Øƒ¦ìG¾V6*Hˆ2¢ùÄ)¯s¥õèh~'ªåíŞÊñ£Õ›%TQ£rëXå;û^Ì¶rP[¸¾UdÑÎIûìÍïD
à‘†´Í‹²÷yù¾ô«ˆ2<ø9næPvyğSrğ8€•µ!|Ûg®™¢ §Zyëe
„‰0Ü#q]uG'AÁ4ÒŒ¶e|ıù$ˆßÓ võz¥ñÏp^V³Ã2ÏÕ=¾Ø@Ï§kÍ<=ò¶1p£E_ù Û&v„KåÑÿœ‹JÆœ§ÈêÃĞzj³)	eí[ô1M¾?¶€K)¥ls!‹ùZXAâïçeOèçdÒ"c¼İác#³®Ğ£&­
Ó(c€wZ‰Çä¹©‘é<Úï)¬w¨ˆ2 T3§ 9¿Àš@àí0åÌ?Œÿ&‰šÇ7B×œ^ ÚQ #”Á^ìåÍ®ôwe]ûøŞıS!OÅ›çøW¤Êºq¹¥ıÓ"’·Ò¥¿o£`i£|Å\~C*ƒ¤h‹ùqˆ5 "O©y^¥éTÔ´—Âº÷ˆêi%Mné5*ˆu‡5m=e'¨•`×Œs8ìÇ¤º¸ª»\aÊ·ÇÜÔªô
IÛm´Á5•7,0.·‰’¡…|òxm8­«~ìTÊ…¿.ÆˆÈ{rº–¸É¿›ƒî%rúºFHßÿáN!÷µ¥á~ç[ÜG¬Å2ÿàŠşíËÎĞ¼şZÙóõÍŸsŒÑÔGf:–Bğ°‰?\>u×ÊGŠÇl4ÇµœÄÓ2æÀeI&u»óÄè3ÁÖó$àüo‰Ã2*!À.¥±òÉ±sC»v}×© Ññµ>oâíÿü Ô;İp‚Yù %Í‚”Íç’–ãÇ*ª›d<§Â2W£ùD2@¥Ó‚ĞqOı ;S0¯¸CÜûµPªøĞåJŒG! ½ÖB
‚¿@N)¶yİíR:B«êºLc½ª^œƒŒÿo+ÎüP±üÇ³$œoˆªƒ¦³zW[)ó8uf£'afM7›ª’aWíNXDe„ç®ªR“†¦ê—Íï˜¶»§)TîË©ñİ*BÍÏş	ùAmŸÖF„#ƒçâÑ«a’Ìæ9S&8Èèi7‚W~íáÕiCğ:Û§õ )øàÊÏk]&íDq&^Â¬¦0Ë«DÊÙ‘I#,KŸ»âÉ•Ñµó‚O3ÙÜı t„~m5$»ìÛ‰¤4-´,åÌPÕ*ÅwëêSßh4{Õ«° 5¸×¿–vır½}ğQÄro)†Jwºº¶kºß¥­CÙİ¶Ò8k­GëÄHQg•÷Õ—zCTıç?„'Iû¨
æsæq ¹íı5Ğs™Ü‡Z;Kt¾R	5>ˆ£¢Î©í
dİ¾\GÀ»Š¾t‘iÔ‘”¹¿¿Í¥ˆöİXµöo+õÜØB¿§ØB{¶lëFÃºòs†(B ÿ¤^örWÿ£Î£m\Ü1&øKÙïÔAnÙ„áÉ†Ç¦>şNtõù¯\š„
ã¦rQğ¿E^MÅ?dGœ¹¨Ã–ÍÕ-¡Ş¹63Ë2÷¯ª"½;Ôßa3WµïO1f¤1D²ãPgŒ…KæÒÃ-_¥=kß÷×sje¸E2=Ädq…EÆ<Ìïÿ±3ÔuÎVË/³)ˆêf×¸c; •+ú×ÈÚ©æ¼ÈıÏ?Ó]ƒ‚’mhÃ¾ä'~ÍîŞG{Hú<f6F"g¹±]¬êÙÁzƒ¾í‘Z/ÆÏ7”øÒwàëSß·9«"È±;9iŸmkĞ£×•¹"»ÛP?@w«¤«Bl¾'‚çóïn®œß†8aG0dpêDÕğ³×øüvÓ¬3­æ aíÅ
4Ì	1aÍp”¸»°ibZàAóûg\7G8PšíÅr­*dîj?FäÊNeÈ¥†;%×1æÜ¶x»°núÓ†^Ç²ØÜ¦ß›ÄgCgL3¬ïdá¹=(%­*&©¬ù´ XÏBh¸§ºçg’%C¹/“lE4B"À=]O4j­ ı&:û§€ËÃzëS7ƒoú¾~Ìw¿ùäÊæ@Vã+9´mŸ(Ğ³ïUt“hÅÙ(ŞEã
šêÌ+À¡î\—Ì#}^ûÚ`¼ßçï«Œ©?şXœO¯o‹çùÑOşßJÍ[ĞsDÏ¥6Œ<‰ùÊJ™_½dí¾lvc}.äå×(÷¥NĞ”CğZZVEûèÅšë)ôZtÃöŒ~y9GÂAq»È+8EÆyËò[SiE5å©µcÉxöÚÁ?zeÄÄ+­:¨rbš¤U:cù'ˆ‰Ç™¼ûğóÃ*ù¼ëÎ»réÆBªÿ‰UkigziÈÃš°ÁÌ6S›–ü¦=?¡Ò&MíOÏñ…öË€Ã1ßXÙÎ”’Á•Ÿ’£Q‹‚×œ‹‚#tsê\ÈÅç™´ÜËø9T‚¬á~ãLkƒ'Y%ğ³EEponÅ"˜X2~ŞK·&ÄÔíf’}’@$‘ãËrÃ ×Å&_ÌôÄObŸùYsmbúı>Õ´ùDİ«–xç…-ìõÒê\˜AìÍİ¢(g"ÿD'Û¼#×OªçµæÅDô°§Éºfù€¯HQ£<²…¼ªtc_”-¶geÉæø_15 ÇüLm‘XİšÕõÂ¤¿1)>¬—k"‹n#Mæ]yB¤ÓÕqøÜ¯Øô‰’F×¼-]ŸÅ5aÒ4~É¯`KyV-É_pBÊ^â¤Ô+c‹ıcJŒm^mÎ˜ÑŸUs7BNÑ¾e§pµÀ;ê˜k»`É/~z‰`SÑŸ>.³ßšne—>n”IEüu$Æ~÷vøBâa¼[7¡Ü2ğul1'ˆY@·/ÃËê|&÷ğ@ĞCÅN¾,ÍÂ#
şÙ44ï
tÚä
(¶ÏßÚÕ%ŠôYÄsa•Ñö&BâoùG^5ÿLFêò8£sÜDåzÊ]fŸc
/BBß#Ğ(.Ùşá`‰#Œÿ“œ18Mq²â8_ Íú`Ÿ~´RfYrÓgãúÿŠœ™Ás½ÀK¡d¬ò¿¢è¥Îæiûü‘aÉåæşO÷Usòxô«ã-¨ªåÄLãğG#ÿêŒOˆØ¯ô_fÎY…ÆOyÒGÉ®ıŸ-RèÛ\ÅòcV'ùï†xú–2 yúIÄ•
° ÆVùH#wäÈµú¦¤Ë|g…¼eñøox‡”c~ö+â.øü€šİNÙÃã7ˆRuUSi÷cŠæŒªöPè><Û%ïå;“xä¦ „«_½€”OŞ¢n©ÄŒ¥Ç0.ÂŸ‘µI½ß™Î^¤İÕÚ‹yª¾µAoï·…±Ër¿