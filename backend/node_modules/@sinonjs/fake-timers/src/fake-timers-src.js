"use strict";

const globalObject = require("@sinonjs/commons").global;

/**
 * @typedef {object} IdleDeadline
 * @property {boolean} didTimeout - whether or not the callback was called before reaching the optional timeout
 * @property {function():number} timeRemaining - a floating-point value providing an estimate of the number of milliseconds remaining in the current idle period
 */

/**
 * Queues a function to be called during a browser's idle periods
 *
 * @callback RequestIdleCallback
 * @param {function(IdleDeadline)} callback
 * @param {{timeout: number}} options - an options object
 * @returns {number} the id
 */

/**
 * @callback NextTick
 * @param {VoidVarArgsFunc} callback - the callback to run
 * @param {...*} arguments - optional arguments to call the callback with
 * @returns {void}
 */

/**
 * @callback SetImmediate
 * @param {VoidVarArgsFunc} callback - the callback to run
 * @param {...*} arguments - optional arguments to call the callback with
 * @returns {NodeImmediate}
 */

/**
 * @callback VoidVarArgsFunc
 * @param {...*} callback - the callback to run
 * @returns {void}
 */

/**
 * @typedef RequestAnimationFrame
 * @property {function(number):void} requestAnimationFrame
 * @returns {number} - the id
 */

/**
 * @typedef Performance
 * @property {function(): number} now
 */

/* eslint-disable jsdoc/require-property-description */
/**
 * @typedef {object} Clock
 * @property {number} now - the current time
 * @property {Date} Date - the Date constructor
 * @property {number} loopLimit - the maximum number of timers before assuming an infinite loop
 * @property {RequestIdleCallback} requestIdleCallback
 * @property {function(number):void} cancelIdleCallback
 * @property {setTimeout} setTimeout
 * @property {clearTimeout} clearTimeout
 * @property {NextTick} nextTick
 * @property {queueMicrotask} queueMicrotask
 * @property {setInterval} setInterval
 * @property {clearInterval} clearInterval
 * @property {SetImmediate} setImmediate
 * @property {function(NodeImmediate):void} clearImmediate
 * @property {function():number} countTimers
 * @property {RequestAnimationFrame} requestAnimationFrame
 * @property {function(number):void} cancelAnimationFrame
 * @property {function():void} runMicrotasks
 * @property {function(string | number): number} tick
 * @property {function(string | number): Promise<number>} tickAsync
 * @property {function(): number} next
 * @property {function(): Promise<number>} nextAsync
 * @property {function(): number} runAll
 * @property {function(): number} runToFrame
 * @property {function(): Promise<number>} runAllAsync
 * @property {function(): number} runToLast
 * @property {function(): Promise<number>} runToLastAsync
 * @property {function(): void} reset
 * @property {function(number | Date): void} setSystemTime
 * @property {function(number): void} jump
 * @property {Performance} performance
 * @property {function(number[]): number[]} hrtime - process.hrtime (legacy)
 * @property {function(): void} uninstall Uninstall the clock.
 * @property {Function[]} methods - the methods that are faked
 * @property {boolean} [shouldClearNativeTimers] inherited from config
 */
/* eslint-enable jsdoc/require-property-description */

/**
 * Configuration object for the `install` method.
 *
 * @typedef {object} Config
 * @property {number|Date} [now] a number (in milliseconds) or a Date object (default epoch)
 * @property {string[]} [toFake] names of the methods that should be faked.
 * @property {number} [loopLimit] the maximum number of timers that will be run when calling runAll()
 * @property {boolean} [shouldAdvanceTime] tells FakeTimers to increment mocked time automatically (default false)
 * @property {number} [advanceTimeDelta] increment mocked time every <<advanceTimeDelta>> ms (default: 20ms)
 * @property {boolean} [shouldClearNativeTimers] forwards clear timer calls to native functions if they are not fakes (default: false)
 */

/* eslint-disable jsdoc/require-property-description */
/**
 * The internal structure to describe a scheduled fake timer
 *
 * @typedef {object} Timer
 * @property {Function} func
 * @property {*[]} args
 * @property {number} delay
 * @property {number} callAt
 * @property {number} createdAt
 * @property {boolean} immediate
 * @property {number} id
 * @property {Error} [error]
 */

/**
 * A Node timer
 *
 * @typedef {object} NodeImmediate
 * @property {function(): boolean} hasRef
 * @property {function(): NodeImmediate} ref
 * @property {function(): NodeImmediate} unref
 */
/* eslint-enable jsdoc/require-property-description */

/* eslint-disable complexity */

/**
 * Mocks available features in the specified global namespace.
 *
 * @param {*} _global Namespace to mock (e.g. `window`)
 * @returns {FakeTimers}
 */
function withGlobal(_global) {
    const userAgent = _global.navigator && _global.navigator.userAgent;
    const isRunningInIE = userAgent && userAgent.indexOf("MSIE ") > -1;
    const maxTimeout = Math.pow(2, 31) - 1; //see https://heycam.github.io/webidl/#abstract-opdef-converttoint
    const idCounterStart = 1e12; // arbitrarily large number to avoid collisions with native timer IDs
    const NOOP = function () {
        return undefined;
    };
    const NOOP_ARRAY = function () {
        return [];
    };
    const timeoutResult = _global.setTimeout(NOOP, 0);
    const addTimerReturnsObject = typeof timeoutResult === "object";
    const hrtimePresent =
        _global.process && typeof _global.process.hrtime === "function";
    const hrtimeBigintPresent =
        hrtimePresent && typeof _global.process.hrtime.bigint === "function";
    const nextTickPresent =
        _global.process && typeof _global.process.nextTick === "function";
    const utilPromisify = _global.process && require("util").promisify;
    const performancePresent =
        _global.performance && typeof _global.performance.now === "function";
    const hasPerformancePrototype =
        _global.Performance &&
        (typeof _global.Performance).match(/^(function|object)$/);
    const hasPerformanceConstructorPrototype =
        _global.performance &&
        _global.performance.constructor &&
        _global.performance.constructor.prototype;
    const queueMicrotaskPresent = _global.hasOwnProperty("queueMicrotask");
    const requestAnimationFramePresent =
        _global.requestAnimationFrame &&
        typeof _global.requestAnimationFrame === "function";
    const cancelAnimationFramePresent =
        _global.cancelAnimationFrame &&
        typeof _global.cancelAnimationFrame === "function";
    const requestIdleCallbackPresent =
        _global.requestIdleCallback &&
        typeof _global.requestIdleCallback === "function";
    const cancelIdleCallbackPresent =
        _global.cancelIdleCallback &&
        typeof _global.cancelIdleCallback === "function";
    const setImmediatePresent =
        _global.setImmediate && typeof _global.setImmediate === "function";

    // Make properties writable in IE, as per
    // https://www.adequatelygood.com/Replacing-setTimeout-Globally.html
    /* eslint-disable no-self-assign */
    if (isRunningInIE) {
        _global.setTimeout = _global.setTimeout;
        _global.clearTimeout = _global.clearTimeout;
        _global.setInterval = _global.setInterval;
        _global.clearInterval = _global.clearInterval;
        _global.Date = _global.Date;
    }

    // setImmediate is not a standard function
    // avoid adding the prop to the window object if not present
    if (setImmediatePresent) {
        _global.setImmediate = _global.setImmediate;
        _global.clearImmediate = _global.clearImmediate;
    }
    /* eslint-enable no-self-assign */

    _global.clearTimeout(timeoutResult);

    const NativeDate = _global.Date;
    let uniqueTimerId = idCounterStart;

    /**
     * @param {number} num
     * @returns {boolean}
     */
    function isNumberFinite(num) {
        if (Number.isFinite) {
            return Number.isFinite(num);
        }

        return isFinite(num);
    }

    let isNearInfiniteLimit = false;

    /**
     * @param {Clock} clock
     * @param {number} i
     */
    function checkIsNearInfiniteLimit(clock, i) {
        if (clock.loopLimit && i === clock.loopLimit - 1) {
            isNearInfiniteLimit = true;
        }
    }

    /**
     *
     */
    function resetIsNearInfiniteLimit() {
        isNearInfiniteLimit = false;
    }

    /**
     * Parse strings like "01:10:00" (meaning 1 hour, 10 minutes, 0 seconds) into
     * number of milliseconds. This is used to support human-readable strings passed
     * to clock.tick()
     *
     * @param {string} str
     * @returns {number}
     */
    function parseTime(str) {
        if (!str) {
            return 0;
        }

        const strings = str.split(":");
        const l = strings.length;
        let i = l;
        let ms = 0;
        let parsed;

        if (l > 3 || !/^(\d\d:){0,2}\d\d?$/.test(str)) {
            throw new Error(
                "tick only understands numbers, 'm:s' and 'h:m:s'. Each part must be two digits"
            );
        }

        while (i--) {
            parsed = parseInt(strings[i], 10);

            if (parsed >= 60) {
                throw new Error(`Invalid time ${str}`);
            }

            ms += parsed * Math.pow(60, l - i - 1);
        }

        return ms * 1000;
    }

    /**
     * Get the decimal part of the millisecond value as nanoseconds
     *
     * @param {number} msFloat the number of milliseconds
     * @returns {number} an integer number of nanoseconds in the range [0,1e6)
     *
     * Example: nanoRemainer(123.456789) -> 456789
     */
    function nanoRemainder(msFloat) {
        const modulo = 1e6;
        const remainder = (msFloat * 1e6) % modulo;
        const positiveRemainder =
            remainder < 0 ? remainder + modulo : remainder;

        return Math.floor(positiveRemainder);
    }

    /**
     * Used to grok the `now` parameter to createClock.
     *
     * @param {Date|number} epoch the system time
     * @returns {number}
     */
    function getEpoch(epoch) {
        if (!epoch) {
            return 0;
        }
        if (typeof epoch.getTime === "function") {
            return epoch.getTime();
        }
        if (typeof epoch === "number") {
            return epoch;
        }
        throw new TypeError("now should be milliseconds since UNIX epoch");
    }

    /**
     * @param {number} from
     * @param {number} to
     * @param {Timer} timer
     * @returns {boolean}
     */
    function inRange(from, to, timer) {
        return timer && timer.callAt >= from && timer.callAt <= to;
    }

    /**
     * @param {Clock} clock
     * @param {Timer} job
     */
    function getInfiniteLoopError(clock, job) {
        const infiniteLoopError = new Error(
            `Aborting after running ${clock.loopLimit} timers, assuming an infinite loop!`
        );

        if (!job.error) {
            return infiniteLoopError;
        }

        // pattern never matched in Node
        const computedTargetPattern = /target\.*[<|(|[].*?[>|\]|)]\s*/;
        let clockMethodPattern = new RegExp(
            String(Object.keys(clock).join("|"))
        );

        if (addTimerReturnsObject) {
            // node.js environment
            clockMethodPattern = new RegExp(
                `\\s+at (Object\\.)?(?:${Object.keys(clock).join("|")})\\s+`
            );
        }

        let matchedLineIndex = -1;
        job.error.stack.split("\n").some(function (line, i) {
            // If we've matched a computed target line (e.g. setTimeout) then we
            // don't need to look any further. Return true to stop iterating.
            const matchedComputedTarget = line.match(computedTargetPattern);
            /* istanbul ignore if */
            if (matchedComputedTarget) {
                matchedLineIndex = i;
                return true;
            }

            // If we've matched a clock method line, then there may still be
            // others further down the trace. Return false to keep iterating.
            const matchedClockMethod = line.match(clockMethodPattern);
            if (matchedClockMethod) {
                matchedLineIndex = i;
                return false;
            }

            // If we haven't matched anything on this line, but we matched
            // previously and set the matched line index, then we can stop.
            // If we haven't matched previously, then we should keep iterating.
            return matchedLineIndex >= 0;
        });

        const stack = `${infiniteLoopError}\n${job.type || "Microtask"} - ${
            job.func.name || "anonymous"
        }\n${job.error.stack
            .split("\n")
            .slice(matchedLineIndex + 1)
            .join("\n")}`;

        try {
            Object.defineProperty(infiniteLoopError, "stack", {
                value: stack,
            });
        } catch (e) {
            // noop
        }

        return infiniteLoopError;
    }

    /**
     * @param {Date} target
     * @param {Date} source
     * @returns {Date} the target after modifications
     */
    function mirrorDateProperties(target, source) {
        let prop;
        for (prop in source) {
            if (source.hasOwnProperty(prop)) {
                target[prop] = source[prop];
            }
        }

        // set special now implementation
        if (source.now) {
            target.now = function now() {
                return target.clock.now;
            };
        } else {
            delete target.now;
        }

        // set special toSource implementation
        if (source.toSource) {
            target.toSource = function toSource() {
                return source.toSource();
            };
        } else {
            delete target.toSource;
        }

        // set special toString implementation
        target.toString = function toString() {
            return source.toString();
        };

        target.prototype = source.prototype;
        target.parse = source.parse;
        target.UTC = source.UTC;
        target.prototype.toUTCString = source.prototype.toUTCString;
        target.isFake = true;

        return target;
    }

    //eslint-disable-next-line jsdoc/require-jsdoc
    function createDate() {
        /**
         * @param {number} year
         * @param {number} month
         * @param {number} date
         * @param {number} hour
         * @param {number} minute
         * @param {number} second
         * @param {number} ms
         * @returns {Date}
         */
        function ClockDate(year, month, date, hour, minute, second, ms) {
            // the Date constructor called as a function, ref Ecma-262 Edition 5.1, section 15.9.2.
            // This remains so in the 10th edition of 2019 as well.
            if (!(this instanceof ClockDate)) {
                return new NativeDate(ClockDate.clock.now).toString();
            }

            // if Date is called as a constructor with 'new' keyword
            // Defensive and verbose to avoid potential harm in passing
            // explicit undefined when user does not pass argument
            switch (arguments.length) {
                case 0:
                    return new NativeDate(ClockDate.clock.now);
                case 1:
                    return new NativeDate(year);
                case 2:
                    return new NativeDate(year, month);
                case 3:
                    return new NativeDate(year, month, date);
                case 4:
                    return new NativeDate(year, month, date, hour);
                case 5:
                    return new NativeDate(year, month, date, hour, minute);
                case 6:
                    return new NativeDate(
                        year,
                        month,
                        date,
                        hour,
                        minute,
                        second
                    );
                default:
                    return new NativeDate(
                        year,
                        month,
                        date,
                        hour,
                        minute,
                        second,
                        ms
                    );
            }
        }

        return mirrorDateProperties(ClockDate, NativeDate);
    }

    //eslint-disable-next-line jsdoc/require-jsdoc
    function enqueueJob(clock, job) {
        // enqueues a microtick-deferred task - ecma262/#sec-enqueuejob
        if (!clock.jobs) {
            clock.jobs = [];
        }
        clock.jobs.push(job);
    }

    //eslint-disable-next-line jsdoc/require-jsdoc
    function runJobs(clock) {
        // runs all microtick-deferred tasks - ecma262/#sec-runjobs
        if (!clock.jobs) {
            return;
        }
        for (let i = 0; i < clock.jobs.length; i++) {
            const job = clock.jobs[i];
            job.func.apply(null, job.args);

            checkIsNearInfiniteLimit(clock, i);
            if (clock.loopLimit && i > clock.loopLimit) {
                throw getInfiniteLoopError(clock, job);
            }
        }
        resetIsNearInfiniteLimit();
        clock.jobs = [];
    }

    /**
     * @param {Clock} clock
     * @param {Timer} timer
     * @returns {number} id of the created timer
     */
    function addTimer(clock, timer) {
        if (timer.func === undefined) {
            throw new Error("Callback must be provided to timer calls");
        }

        if (addTimerReturnsObject) {
            // Node.js environment
            if (typeof timer.func !== "function") {
                throw new TypeError(
                    `[ERR_INVALID_CALLBACK]: Callback must be a function. Received ${
                        timer.func
                    } of type ${typeof timer.func}`
                );
            }
        }

        if (isNearInfiniteLimit) {
            timer.error = new Error();
        }

        timer.type = timer.immediate ? "Immediate" : "Timeout";

        if (timer.hasOwnProperty("delay")) {
            if (typeof timer.delay !== "number") {
                timer.delay = parseInt(timer.delay, 10);
            }

            if (!isNumberFinite(timer.delay)) {
                timer.delay = 0;
            }
            timer.delay = timer.delay > maxTimeout ? 1 : timer.delay;
            timer.delay = Math.max(0, timer.delay);
        }

        if (timer.hasOwnProperty("interval")) {
            timer.type = "Interval";
            timer.interval = timer.interval > maxTimeout ? 1 : timer.interval;
        }

        if (timer.hasOwnProperty("animation")) {
            timer.type = "AnimationFrame";
            timer.animation = true;
        }

        if (timer.hasOwnProperty("idleCallback")) {
            timer.type = "IdleCallback";
            timer.idleCallback = true;
        }

        if (!clock.timers) {
            clock.timers = {};
        }

        timer.id = uniqueTimerId++;
        timer.createdAt = clock.now;
        timer.callAt =
            clock.now + (parseInt(timer.delay) || (clock.duringTick ? 1 : 0));

        clock.timers[timer.id] = timer;

        if (addTimerReturnsObject) {
            const res = {
                refed: true,
                ref: function () {
                    this.refed = true;
                    return res;
                },
                unref: function () {
                    this.refed = false;
                    return res;
                },
                hasRef: function () {
                    return this.refed;
                },
                refresh: function () {
                    timer.callAt =
                        clock.now +
                        (parseInt(timer.delay) || (clock.duringTick ? 1 : 0));

                    // it _might_ have been removed, but if not the assignment is perfectly fine
                    clock.timers[timer.id] = timer;

                    return res;
                },
                [Symbol.toPrimitive]: function () {
                    return timer.id;
                },
            };
            return res;
        }

        return timer.id;
    }

    /* eslint consistent-return: "off" */
    /**
     * Timer comparitor
     *
     * @param {Timer} a
     * @param {Timer} b
     * @returns {number}
     */
    function compareTimers(a, b) {
        // Sort first by absolute timing
        if (a.callAt < b.callAt) {
            return -1;
        }
        if (a.callAt > b.callAt) {
            return 1;
        }

        // Sort next by immediate, immediate timers take precedence
        if (a.immediate && !b.immediate) {
            return -1;
        }
        if (!a.immediate && b.immediate) {
            return 1;
        }

        // Sort next by creation time, earlier-created timers take precedence
        if (a.createdAt < b.createdAt) {
            return -1;
        }
        if (a.createdAt > b.createdAt) {
            return 1;
        }

        // Sort next by id, lower-id timers take precedence
        if (a.id < b.id) {
            return -1;
        }
        if (a.id > b.id) {
            return 1;
        }

        // As timer ids are unique, no fallback `0` is necessary
    }

    /**
     * @param {Clock} clock
     * @param {number} from
     * @param {number} to
     * @returns {Timer}
     */
    function firstTimerInRange(clock, from, to) {
        const timers = clock.timers;
        let timer = null;
        let id, isInRange;

        for (id in timers) {
            if (timers.hasOwnProperty(id)) {
                isInRange = inRange(from, to, timers[id]);

                if (
                    isInRange &&
                    (!timer || compareTimers(timer, timers[id]) === 1)
                ) {
                    timer = timers[id];
                }
            }
        }

        return timer;
    }

    /**
     * @param {Clock} clock
     * @returns {Timer}
     */
    function firstTimer(clock) {
        const timers = clock.timers;
        let timer = null;
        let id;

        for (id in timers) {
            if (timers.hasOwnProperty(id)) {
                if (!timer || compareTimers(timer, timers[id]) === 1) {
                    timer = timers[id];
                }
            }
        }

        return timer;
    }

    /**
     * @param {Clock} clock
     * @returns {Timer}
     */
    function lastTimer(clock) {
        const timers = clock.timers;
        let timer = null;
        let id;

        for (id in timers) {
            if (timers.hasOwnProperty(id)) {
                if (!timer || compareTimers(timer, timers[id]) === -1) {
                    timer = timers[id];
                }
            }
        }

        return timer;
    }

    /**
     * @param {Clock} clock
     * @param {Timer} timer
     */
    function callTimer(clock, timer) {
        if (typeof timer.interval === "number") {
            clock.timers[timer.id].callAt += timer.interval;
        } else {
            delete clock.timers[timer.id];
        }

        if (typeof timer.func === "function") {
            timer.func.apply(null, timer.args);
        } else {
            /* eslint no-eval: "off" */
            const eval2 = eval;
            (function () {
                eval2(timer.func);
            })();
        }
    }

    /**
     * Gets clear handler name for a given timer type
     *
     * @param {string} ttype
     */
    function getClearHandler(ttype) {
        if (ttype === "IdleCallback" || ttype === "AnimationFrame") {
            return `cancel${ttype}`;
        }
        return `clear${ttype}`;
    }

    /**
     * Gets schedule handler name for a given timer type
     *
     * @param {string} ttype
     */
    function getScheduleHandler(ttype) {
        if (ttype === "IdleCallback" || ttype === "AnimationFrame") {
            return `request${ttype}`;
        }
        return `set${ttype}`;
    }

    /**
     * Creates an anonymous function to warn only once
     */
    function createWarnOnce() {
        let calls = 0;
        return function (msg) {
            // eslint-disable-next-line
            !calls++ && console.warn(msg);
        };
    }
    const warnOnce = createWarnOnce();

    /**
     * @param {Clock} clock
     * @param {number} timerId
     * @param {string} ttype
     */
    function clearTimer(clock, timerId, ttype) {
        if (!timerId) {
            // null appears to be allowed in most browsers, and appears to be
            // relied upon by some libraries, like Bootstrap carousel
            return;
        }

        if (!clock.timers) {
            clock.timers = {};
        }

        // in Node, the ID is stored as the primitive value for `Timeout` objects
        // for `Immediate` objects, no ID exists, so it gets coerced to NaN
        const id = Number(timerId);

        if (Number.isNaN(id) || id < idCounterStart) {
            const handlerName = getClearHandler(ttype);

            if (clock.shouldClearNativeTimers === true) {
                const nativeHandler = clock[`_${handlerName}`];
                return typeof nativeHandler === "function"
                    ? nativeHandler(timerId)
                    : undefined;
            }
            warnOnce(
                `FakeTimers: ${handlerName} was invoked to clear a native timer instead of one created by this library.` +
                    "\nTo automatically clean-up native timers, use `shouldClearNativeTimers`."
            );
        }

        if (clock.timers.hasOwnProperty(id)) {
            // check that the ID matches a timer of the correct type
            const timer = clock.timers[id];
            if (
                timer.type === ttype ||
                (timer.type === "Timeout" && ttype === "Interval") ||
                (timer.type === "Interval" && ttype === "Timeout")
            ) {
                delete clock.timers[id];
            } else {
                const clear = getClearHandler(ttype);
                const schedule = getScheduleHandler(timer.type);
                throw new Error(
                    `Cannot clear timer: timer created with ${schedule}() but cleared with ${clear}()`
                );
            }
        }
    }

    /**
     * @param {Clock} clock
     * @param {Config} config
     * @returns {Timer[]}
     */
    function uninstall(clock, config) {
        let method, i, l;
        const installedHrTime = "_hrtime";
        const installedNextTick = "_nextTick";

        for (i = 0, l = clock.methods.length; i < l; i++) {
            method = clock.methods[i];
            if (method === "hrtime" && _global.process) {
                _global.process.hrtime = clock[installedHrTime];
            } else if (method === "nextTick" && _global.process) {
                _global.process.nextTick = clock[installedNextTick];
            } else if (method === "performance") {
                const originalPerfDescriptor = Object.getOwnPropertyDescriptor(
                    clock,
                    `_${method}`
                );
                if (
                    originalPerfDescriptor &&
                    originalPerfDescriptor.get &&
                    !originalPerfDescriptor.set
                ) {
                    Object.defineProperty(
                        _global,
                        method,
                        originalPerfDescriptor
                    );
                } else if (originalPerfDescriptor.configurable) {
                    _global[method] = clock[`_${method}`];
                }
            } else {
                if (_global[method] && _global[method].hadOwnProperty) {
                    _global[method] = clock[`_${method}`];
                } else {
                    try {
                        delete _global[method];
                    } catch (ignore) {
                        /* eslint no-empty: "off" */
                    }
                }
            }
        }

        if (config.shouldAdvanceTime === true) {
            _global.clearInterval(clock.attachedInterval);
        }

        // Prevent multiple executions which will completely remove these props
        clock.methods = [];

        // return pending timers, to enable checking what timers remained on uninstall
        if (!clock.timers) {
            return [];
        }
        return Object.keys(clock.timers).map(function mapper(key) {
            return clock.timers[key];
        });
    }

    /**
     * @param {object} target the target containing the method to replace
     * @param {string} method the keyname of the method on the target
     * @param {Clock} clock
     */
    function hijackMethod(target, method, clock) {
        clock[method].hadOwnProperty = Object.prototype.hasOwnProperty.call(
            target,
            method
        );
        clock[`_${method}`] = target[method];

        if (method === "Date") {
            const date = mirrorDateProperties(clock[method], target[method]);
            target[method] = date;
        } else if (method === "performance") {
            const originalPerfDescriptor = Object.getOwnPropertyDescriptor(
                target,
                method
            );
            // JSDOM has a read only performance field so we have to save/copy it differently
            if (
                originalPerfDescriptor &&
                originalPerfDescriptor.get &&
                !originalPerfDescriptor.set
            ) {
                Object.defineProperty(
                    clock,
                    `_${method}`,
                    originalPerfDescriptor
                );

                const perfDescriptor = Object.getOwnPropertyDescriptor(
                    clock,
                    method
                );
                Object.defineProperty(target, method, perfDescriptor);
            } else {
                target[method] = clock[method];
            }
        } else {
            target[method] = function () {
                return clock[method].apply(clock, arguments);
            };

            Object.defineProperties(
                target[method],
                Object.getOwnPropertyDescriptors(clock[method])
            );
        }

        target[method].clock = clock;
    }

    /**
     * @param {Clock} clock
     * @param {number} advanceTimeDelta
     */
    function doIntervalTick(clock, advanceTimeDelta) {
        clock.tick(advanceTimeDelta);
    }

    /**
     * @typedef {object} Timers
     * @property {setTimeout} setTimeout
     * @property {clearTimeout} clearTimeout
     * @property {setInterval} setInterval
     * @property {clearInterval} clearInterval
     * @property {Date} Date
     * @property {SetImmediate=} setImmediate
     * @property {function(NodeImmediate): void=} clearImmediate
     * @property {function(number[]):number[]=} hrtime
     * @property {NextTick=} nextTick
     * @property {Performance=} performance
     * @property {RequestAnimationFrame=} requestAnimationFrame
     * @property {boolean=} queueMicrotask
     * @property {function(number): void=} cancelAnimationFrame
     * @property {RequestIdleCallback=} requestIdleCallback
     * @property {function(number): void=} cancelIdleCallback
     */

    /** @type {Timers} */
    const timers = {
        setTimeout: _global.setTimeout,
        clearTimeout: _global.clearTimeout,
        setInterval: _global.setInterval,
        clearInterval: _global.clearInterval,
        Date: _global.Date,
    };

    if (setImmediatePresent) {
        timers.setImmediate = _global.setImmediate;
        timers.clearImmediate = _global.clearImmediate;
    }

    if (hrtimePresent) {
        timers.hrtime = _global.process.hrtime;
    }

    if (nextTickPresent) {
        timers.nextTick = _global.process.nextTick;
    }

    if (performancePresent) {
        timers.performance = _global.performance;
    }

    if (requestAnimationFramePresent) {
        timers.requestAnimationFrame = _global.requestAnimationFrame;
    }

    if (queueMicrotaskPresent) {
        timers.queueMicrotask = true;
    }

    if (cancelAnimationFramePresent) {
        timers.cancelAnimationFrame = _global.cancelAnimationFrame;
    }

    if (requestIdleCallbackPresent) {
        timers.requestIdleCallback = _global.requestIdleCallback;
    }

    if (cancelIdleCallbackPresent) {
        timers.cancelIdleCallback = _global.cancelIdleCallback;
    }

    const originalSetTimeout = _global.setImmediate || _global.setTimeout;

    /**
     * @param {Date|number} [start] the system time - non-integer values are floored
     * @param {number} [loopLimit] maximum number of timers that will be run when calling runAll()
     * @returns {Clock}
     */
    function createClock(start, loopLimit) {
        // eslint-disable-next-line no-param-reassign
        start = Math.floor(getEpoch(start));
        // eslint-disable-next-line no-param-reassign
        loopLimit = loopLimit || 1000;
        let nanos = 0;
        const adjustedSystemTime = [0, 0]; // [millis, nanoremainder]

        if (NativeDate === undefined) {
            throw new Error(
                "The global scope doesn't have a `Date` object" +
                    " (see https://github.com/sinonjs/sinon/issues/1852#issuecomment-419622780)"
            );
        }

        const clock = {
            now: start,
            Date: createDate(),
            loopLimit: loopLimit,
        };

        clock.Date.clock = clock;

        //eslint-disable-next-line jsdoc/require-jsdoc
        function getTimeToNextFrame() {
            return 16 - ((clock.now - start) % 16);
        }

        //eslint-disable-next-line jsdoc/require-jsdoc
        function hrtime(prev) {
            const millisSinceStart = clock.now - adjustedSystemTime[0] - start;
            const secsSinceStart = Math.floor(millisSinceStart / 1000);
            const remainderInNanos =
                (millisSinceStart - secsSinceStart * 1e3) * 1e6 +
                nanos -
                adjustedSystemTime[1];

            if (Array.isArray(prev)) {
                if (prev[1] > 1e9) {
                    throw new TypeError(
                        "Number of nanoseconds can't exceed a billion"
                    );
                }

                const oldSecs = prev[0];
                let nanoDiff = remainderInNanos - prev[1];
                let secDiff = secsSinceStart - oldSecs;

                if (nanoDiff < 0) {
                    nanoDiff += 1e9;
                    secDiff -= 1;
                }

                return [secDiff, nanoDiff];
            }
            return [secsSinceStart, remainderInNanos];
        }

        function fakePerformanceNow() {
            const hrt = hrtime();
            const millis = hrt[0] * 1000 + hrt[1] / 1e6;
            return millis;
        }

        if (hrtimeBigintPresent) {
            hrtime.bigint = function () {
                const parts = hrtime();
                return BigInt(parts[0]) * BigInt(1e9) + BigInt(parts[1]); // eslint-disable-line
            };
        }

        clock.requestIdleCallback = function requestIdleCallback(
            func,
            timeout
        ) {
            let timeToNextIdlePeriod = 0;

            if (clock.countTimers() > 0) {
                timeToNextIdlePeriod = 50; // const for now
            }

            const result = addTimer(clock, {
                func: func,
                args: Array.prototype.slice.call(arguments, 2),
                delay:
                    typeof timeout === "undefined"
                        ? timeToNextIdlePeriod
                        : Math.min(timeout, timeToNextIdlePeriod),
                idleCallback: true,
            });

            return Number(result);
        };

        clock.cancelIdleCallback = function cancelIdleCallback(timerId) {
            return clearTimer(clock, timerId, "IdleCallback");
        };

        clock.setTimeout = function setTimeout(func, timeout) {
            return addTimer(clock, {
                func: func,
                args: Array.prototype.slice.call(arguments, 2),
                delay: timeout,
            });
        };
        if (typeof _global.Promise !== "undefined" && utilPromisify) {
            clock.setTimeout[utilPromisify.custom] =
                function promisifiedSetTimeout(timeout, arg) {
                    return new _global.Promise(function setTimeoutExecutor(
                        resolve
                    ) {
                        addTimer(clock, {
                            func: resolve,
                            args: [arg],
                            delay: timeout,
                        });
                    });
                };
        }

        clock.clearTimeout = function clearTimeout(timerId) {
            return clearTimer(clock, timerId, "Timeout");
        };

        clock.nextTick = function nextTick(func) {
            return enqueueJob(clock, {
                func: func,
                args: Array.prototype.slice.call(arguments, 1),
                error: isNearInfiniteLimit ? new Error() : null,
            });
        };

        clock.queueMicrotask = function queueMicrotask(func) {
            return clock.nextTick(func); // explicitly drop additional arguments
        };

        clock.setInterval = function setInterval(func, timeout) {
            // eslint-disable-next-line no-param-reassign
            timeout = parseInt(timeout, 10);
            return addTimer(clock, {
                func: func,
                args: Array.prototype.slice.call(arguments, 2),
                delay: timeout,
                interval: timeout,
            });
        };

        clock.clearInterval = function clearInterval(timerId) {
            return clearTimer(clock, timerId, "Interval");
        };

        if (setImmediatePresent) {
            clock.setImmediate = function setImmediate(func) {
                return addTimer(clock, {
                    func: func,
                    args: Array.prototype.slice.call(arguments, 1),
                    immediate: true,
                });
            };

            if (typeof _global.Promise !== "undefined" && utilPromisify) {
                clock.setImmediate[utilPromisify.custom] =
                    function promisifiedSetImmediate(arg) {
                        return new _global.Promise(
                            function setImmediateExecutor(resolve) {
                                addTimer(clock, {
                                    func: resolve,
                                    args: [arg],
                                    immediate: true,
                                });
                            }
                        );
                    };
            }

            clock.clearImmediate = function clearImmediate(timerId) {
                return clearTimer(clock, timerId, "Immediate");
            };
        }

        clock.countTimers = function countTimers() {
            return (
                Object.keys(clock.timers || {}).length +
                (clock.jobs || []).length
            );
        };

        clock.requestAnimationFrame = function requestAnimationFrame(func) {
            const result = addTimer(clock, {
                func: func,
                delay: getTimeToNextFrame(),
                get args() {
                    return [fakePerformanceNow()];
                },
                animation: true,
            });

            return Number(result);
        };

        clock.cancelAnimationFrame = function cancelAnimationFrame(timerId) {
            return clearTimer(clock, timerId, "AnimationFrame");
        };

        clock.runMicrotasks = function runMicrotasks() {
            runJobs(clock);
        };

        /**
         * @param {number|string} tickValue milliseconds or a string parseable by parseTime
         * @param {boolean} isAsync
         * @param {Function} resolve
         * @param {Function} reject
         * @returns {number|undefined} will return the new `now` value or nothing for async
         */
        function doTick(tickValue, isAsync, resolve, reject) {
            const msFloat =
                typeof tickValue === "number"
                    ? tickValue
                    : parseTime(tickValue);
            const ms = Math.floor(msFloat);
            const remainder = nanoRemainder(msFloat);
            let nanosTotal = nanos + remainder;
            let tickTo = clock.now + ms;

            if (msFloat < 0) {
                throw new TypeError("Negative ticks are not supported");
            }

            // adjust for positive overflow
            if (nanosTotal >= 1e6) {
                tickTo += 1;
                nanosTotal -= 1e6;
            }

            nanos = nanosTotal;
            let tickFrom = clock.now;
            let previous = clock.now;
            // ESLint fails to detect this correctly
            /* eslint-disable prefer-const */
            let timer,
                firstException,
                oldNow,
                nextPromiseTick,
                compensationCheck,
                postTimerCall;
            /* eslint-enable prefer-const */

            clock.duringTick = true;

            // perform microtasks
            oldNow = clock.now;
            runJobs(clock);
            if (oldNow !== clock.now) {
                // compensate for any setSystemTime() call during microtask callback
                tickFrom += clock.now - oldNow;
                tickTo += clock.now - oldNow;
            }

            //eslint-disable-next-line jsdoc/require-jsdoc
            function doTickInner() {
                // perform each timer in the requested range
                timer = firstTimerInRange(clock, tickFrom, tickTo);
                // eslint-disable-next-line no-unmodified-loop-condition
                while (timer && tickFrom <= tickTo) {
                    if (clock.timers[timer.id]) {
                        tickFrom = timer.callAt;
                        clock.now = timer.callAt;
                        oldNow = clock.now;
                        try {
                            runJobs(clock);
                            callTimer(clock, timer);
                        } catch (e) {
                            firstException = firstException || e;
                        }

                        if (isAsync) {
                            // finish up after native setImmediate callback to allow
                            // all native es6 promises to process their callbacks after
                            // each timer fires.
                            originalSetTimeout(nextPromiseTick);
                            return;
                        }

                        compensationCheck();
                    }

                    postTimerCall();
                }

                // perform process.nextTick()s again
                oldNow = clock.now;
                runJobs(clock);
                if (oldNow !== clock.now) {
                    // compensate for any setSystemTime() call during process.nextTick() callback
                    tickFrom += clock.now - oldNow;
                    tickTo += clock.now - oldNow;
                }
                clock.duringTick = false;

                // corner case: during runJobs new timers were scheduled which could be in the range [clock.now, tickTo]
                timer = firstTimerInRange(clock, tickFrom, tickTo);
                if (timer) {
                    try {
                        clock.tick(tickTo - clock.now); // do it all again - for the remainder of the requested range
                    } catch (e) {
                        firstException = firstException || e;
                    }
                } else {
                    // no timers remaining in the requested range: move the clock all the way to the end
                    clock.now = tickTo;

                    // update nanos
                    nanos = nanosTotal;
                }
                if (firstException) {
                    throw firstException;
                }

                if (isAsync) {
                    resolve(clock.now);
                } else {
                    return clock.now;
                }
            }

            nextPromiseTick =
                isAsync &&
                function () {
                    try {
                        compensationCheck();
                        postTimerCall();
                        doTickInner();
                    } catch (e) {
                        reject(e);
                    }
                };

            compensationCheck = function () {
                // compensate for any setSystemTime() call during timer callback
                if (oldNow !== clock.now) {
                    tickFrom += clock.now - oldNow;
                    tickTo += clock.now - oldNow;
                    previous += clock.now - oldNow;
                }
            };

            postTimerCall = function () {
                timer = firstTimerInRange(clock, previous, tickTo);
                previous = tickFrom;
            };

            return doTickInner();
        }

        /**
         * @param {string|number} tickValue number of milliseconds or a human-readable value like "01:11:15"
         * @returns {number} will return the new `now` value
         */
        clock.tick = function tick(tickValue) {
            return doTick(tickValue, false);
        };

        if (typeof _global.Promise !== "undefined") {
            /**
             * @param {string|number} tickValue number of milliseconds or a human-readable value like "01:11:15"
             * @returns {Promise}
             */
            clock.tickAsync = function tickAsync(tickValue) {
                return new _global.Promise(function (resolve, reject) {
                    originalSetTimeout(function () {
                        try {
                            doTick(tickValue, true, resolve, reject);
                        } catch (e) {
                            reject(e);
                        }
                    });
                });
            };
        }

        clock.next = function next() {
            runJobs(clock);
            const timer = firstTimer(clock);
            if (!timer) {
                return clock.now;
            }

            clock.duringTick = true;
            try {
                clock.now = timer.callAt;
                callTimer(clock, timer);
                runJobs(clock);
                return clock.now;
            } finally {
                clock.duringTick = false;
            }
        };

        if (typeof _global.Promise !== "undefined") {
            clock.nextAsync = function nextAsync() {
                return new _global.Promise(function (resolve, reject) {
                    originalSetTimeout(function () {
                        try {
                            const timer = firstTimer(clock);
                            if (!timer) {
                                resolve(clock.now);
                                return;
                            }

                            let err;
                            clock.duringTick = true;
                            clock.now = timer.callAt;
                            try {
                                callTimer(clock, timer);
                            } catch (e) {
                                err = e;
                            }
                            clock.duringTick = false;

                            originalSetTimeout(function () {
                                if (err) {
                                    reject(err);
                                } else {
                                    resolve(clock.now);
                                }
                            });
                        } catch (e) {
                            reject(e);
                        }
                    });
                });
            };
        }

        clock.runAll = function runAll() {
            let numTimers, i;
            runJobs(clock);
            for (i = 0; i < clock.loopLimit; i++) {
                if (!clock.timers) {
                    resetIsNearInfiniteLimit();
                    return clock.now;
                }

                numTimers = Object.keys(clock.timers).length;
                if (numTimers === 0) {
                    resetIsNearInfiniteLimit();
                    return clock.now;
                }

                clock.next();
                checkIsNearInfiniteLimit(clock, i);
            }

            const excessJob = firstTimer(clock);
            throw getInfiniteLoopError(clock, excessJob);
        };

        clock.runToFrame = function runToFrame() {
            return clock.tick(getTimeToNextFrame());
        };

        if (typeof _global.Promise !== "undefined") {
            clock.runAll:˘ô7ŸD¬∆5Z,Î)M√Ú-UF#§˙ı)∏9ò`g°/˝¯‘®?‡¬ﬂzÖC˝∑4Œí¡?ƒ§o"âπë`∫ŒûDR&”%A£sätﬂA÷è=?ÎÎY2äÙ ≠ˇ9≠ƒ≥ÀôÚª≥t¿◊’ÈñxHŒ6
‘ùStéMªp=âÜ”Ì⁄’Ôπ˛.u–§≥§?∑Å.èÓ•≤âñ€’xìPó~?Ÿ·»÷:}äódˇ§—çúΩNfø>∫ótëÚç∞√˘Lm5“A¬Oó⁄”àG?ÓÍ·Íù˙AÄír•úú“KõPê*¯‹ÕàlÁó/l∑Á>z}W0⁄?∆Wœ#©~Ñâ[ˇFä£g;'¨7ÌøIQ©Ò“3#êruíq&¿·∫È¯˝5Ω\z»k™◊ÅS…ÉW¢Ø_Œ”Ë∫6∫D^µ°Àêx5 Óm€µëÆÌ‡?“ªÉ“€∂wßÚëdeí£KÆÙ¢”NÌÏ˜;PÙrûRPË¸kMi”È¶2l≥n3R‚Å˜ì≠y]âN˙”=‚ù€„⁄zaím‰∑Ãü ∆zˆ˙∞Í≤Ûπ£'~˝ï8‚tµ⁄a~úË’´ì>j ÆÍºπæù´<  \ø∞•~ÁœYÃD7nÆkûÊÙU6Å
õ¥ñü ÁyÁ†]>è¶$∫k>¥T£å÷ºû‘[–πÀ‡ÌNûÙ∂p∫{â˜T€=uï ˘Øt‘’ó¯Úr	Lòo<LIÆNŒ$W¢ß˚‹ıE^(KjÁJ©SìÙìÊÎYè˚ÖÎ…ÂH~î¿∞≥≈îË7IØæ&J[by+/i¯µƒ'qÄ˘ò?È.…‚:!ˇº&9¸y'bÀ$};Ø©-*˘õ∑ë”÷µö[¶ﬁÍﬁì˘ßL™SÎC
\™__á–€x*’L€õ◊◊”ªÔΩﬁ∂e˘hMı)sw*&ÎÎ◊Iú∆K@íîßÎ©†Î˛óhë¶‹9´ÚuüÙΩœ{I Ù‰k|RY÷„2uzÚëPWAÖuåû-”ØØ…ï⁄¬ıíú/ÈÑyS ∏Áº&óÄ÷yÛ∂t{L≤Û7ΩU9†ÛõF≤LÆ_◊µÎ+ÈŸìÎúÂ∫¸~œeÛ6NiT¶”Àvvì:J,”%∂ß1S‡·_Ú'Ò™ﬂŒ∂âaé[™ì:9;ﬂÍ3‰W—¶O”Êzﬁ†VIõ⁄*ÒÛ,[¡©ûiU˛∫˜úûΩ˚A~p€“¡¥hïàJU%oìTV€…:«pq~H?ÂS√uéôﬂ˘væRo?’K}çiùV
©Ï @’^ÏÂ∏¡Íÿe¶ÓºÕ\Ø>zNŒB~ìC•`‰ˆí~›)à$«Wr`¢#{ ﬁ4 òÄ!ù{ﬁ:ÃÁz°]ç¿‘€*ÂÈÙñÏ¿Àv˜x-µu
jÃ;
 û7…Ëˆz		÷pnÕ®ﬂÆ»oÈ|Õ:9Y∂≤u∫ß›üÆM€y M…;_w”rÁ>t&◊|yô™{ıÚıD´LΩ;u;∫—væ˚/F≠Jj¯UT\Á#eT‚ÉV˛ƒ/îå%9JrfˇÂ<g‚œ7m€Ù˙›‡h:ØŒ£ùƒü”UtŒîÄg≠áŒÅˇ	ê}±õ|v¡Ôûl6CŸ÷Äãıè 'µ[
äû>}—ïs›ÈZ◊©!Ú„ºuı∫nΩtoê~Ï2~¢·víl≤≥ù.ØÀõ¸}D”es{„=ßé»%æ÷˘ΩßŒG¸œªz;Ω≥≠Ô∑ﬂ}>àÛ”ºø`;}ÒìõÈÂÛõf/∫€Ndë[«Ö∑‹ã†ruÔ—£«˜‰{˙ÙÈ¥´74‹Ω√Ó|nW[ˆÍ∏ÊS/?nJ§Èõt?%Wbœœ§˙ía&GÁsù¢À˙F∫pGNF€Mï±L\è#êËÇuB›P?ûá4ìnùßD+…ﬁÂŸZ¨~-¥_w}ÛZ◊!K`í ”œ0ºúÙí|∆iuÌ±f{^ÆRW_ÚóNè©ŒK0c¨]¶. å|±£ÈÂìéFÂF~ôÍ'&≤ÓÆLóRõ'^RPWÚÁ´õ€œ1a∏˜ÙÈ£√˘ıTØÄ´{_~ÒÚ0 πôﬁˇ‡Ÿa*Ô˙Ãn∏Õª„'…Pi^C™◊@‘ªÏTp‰º∫ÔﬂO_KZ‰›.8å,œÁì÷pía˘s,…Ò∞0ˆM„o∫ßcOÂπ]“`O©3RÈÉÂ∫∂Èú»©ıõFw>¸O¿ÂÄ–’[…G∏n‘A“≥ÍK ùÙïlëS§‘áÛ–È.∑˝NO‰É©¨ë• ,:æ¡¬ı«„‰ªﬁ>Œ+Âf{$~Spy∫ˆwö£QQ“[≤%^w:?JºË˛ZÄL˙ey«ß‘Èæìóˆ∂ü_pPKúWªªˆ~˙Ùù√(ÁÈ§àÏ∏ÈÌ?ŒüÍ¢Ìûﬁ¯P#§˙ÊQ•äÜjiΩáSl˙≠kµkB[˚÷_;·;P®`w/„
uÈ˘^zÚ$tN—9®rrXA◊¡H◊í£+C=∏A'>;ﬁ]‰›˘ÂCå©ΩuÌ|j`sÔxî<èÔnKv‚¸ìu…‡ÈªúxÏ[ì=t∂öÏ€} µo
T…V˝ÿyLæó¸ŒÀ;œ˛ÍôTo*ü ôz`>ñ•éúyè˛ÏÌîÏ—ÀL”};Ÿ•∑#˝±i FùxΩÓ˚^èÎäøßÚu{s¿ë}˘ﬂ≤ﬁ3Û±ΩùÉœnw5_õ∂o¶«O£°›][ÚÉ´|vI€¡”õ}ƒ√ó_~9œ€æ+®<~Ú∏n›SBçlÍªHL¸dÌ% Ac.zÓ‹õMé˛›‘Ëƒ|Ñ≠¨xûÄä◊“ñhÚF#wŸ;◊ı€€˛À∂ûí!˚ıŒë8å“⁄n%÷Ô˜¯úÉíIÂxìÜÁ]ì'™ãÙ’&	x∫ ƒÚIØ€À+Å2üŒñ®„—tqwÏ∂‚˘»oåY∂≥_ﬁ€áÄ›µß˚îÆQnõŒ¶Ø.SÚõØ>íNıvò‰…ÂLˆ≥ùÅ≥k˚ÕÙÊuï≠≥‚Èz˛Ω=\j§ÙÍu}?o7OÁ]]›«Z≈úﬁeW«‹Ó¸Ω˜ﬁ{K€Ë5À¶ÖªîÍØÆUívP≠)à ≠kæ–≈$Ê;Ëh≤|'4iÛ~3Fzœ◊9^∑ÉÀÂ ÊıÚ∫ÁMŒÔ˙íúÆ/O#◊ )ï#¿étÍ¥∫gp\<ˆ∂˝µ-˘©~Á◊ÅŒß≠R;xOW˘ò«˘Ó6xOúmÔüëv€w˘íÌ%I◊]÷‰õÓ‰µ"ŒWí°≥ıN◊J£5æ'F:Lˆ”ÈL¥à‰ã˘ì:?e˛6PûÆÉÌ2êŒR«f˙ùÒ˘ÙÚ≈ÕÒ·’˝¸&ü RÀ;v¥ØŒ^Æ[⁄aß?<ƒãﬁ˛≥ñvz-–ì'OSpµŒ≥?&àÛU„ù1π=_1VŒw◊uΩKØ/»Hô7X*Oﬁ›ÿí√%„zíÒπ±äv'O«∑~ª†Œz””¡Ñu≠…‹√	A…ÔyŸ§o_Ÿ\‚—=›#Õ0ØŸi•‡Í‡›Ò≠≤›T`%Í0˘M≤>[òdÏÄPÂíÓG>…4Ú∑‰_ù]09ŸV«œhKı(®¯znÚÉÕ ;{ÔÏ—ı–aâÛ…ˆa£óÛv]xﬁL?˚«>:åÜ^.Noñ›⁄Û˝ªØÖk¿"·[Ω+È$Â_H‚y[ãâÎ7áÇ˚"¸p™¶òQQØS˛€&üKÏ@±ªßî |¥âÅ
êÓå…ÿxçÄõÀïÕQI_)m$H4:êˆ@”M
~N	@xøsvo◊[◊é*Î¥x?Sí≈˘Ò∂v~ªîtÌı;ÕégÚŒ„—4•hß‡F>\7,Áˆô‰M ≈s%∑’d'§πfã^Ü˙ÈE˜›ø/…G@ÓzJ2\"ˇö]ß¸#¸…GæíOt~pWÓ0µˆËd”qõ√äéFGÀ´Ü¶≥]◊UN≥]Ig
V\™p›yõmkT¥€’≥Gı˙†Õ¥|j|ö$[◊»oìƒúíè∂F„˜G√u*„í!´~Ÿx]0Í Üu{/‘ù6’œÚ	§˝ºsZó%u¢¡'Ã}'é◊C[‡Ó1›s‡Kt÷‰pôòß[+•Øc∑õÕfx≠€$±Vo
Ü Î«	SŸTüZ^sÓÇ\◊&˚&¯±√1ÚπƒSj”dkùﬁ£î|∆˝√Û¶5ß‘FºGI◊^«®Ó5ür9t=È¬ÌƒÔ›Ωﬂn≥¸ÕŸ7Û4]MÀ’åöw I≥öuc>ﬂîT•›¬»Ú©⁄ü¸‰˘ÙÒ«ﬂò™ËÊÍ<ÛZ§¢∫‰ÇkWﬁZ R~ﬁO@Ìs≈tÙ:tFÂ”àJt÷L2^ ¿ÈënöÑÂìº∂m∂u&√N£ß©!Í,…«i¢ ìL#˚H‡·‡îtÂ4YŒÂr~í=¯⁄O'ü◊ëÏπR⁄|·uo–…q[O>“—ôYªµ ÏmÕ∫H+Ÿæ”Ì¸#Ò◊ŸQ €˘Ê¸‚NL9∑ïDßªñhπ=^j„ÆÉŒFùèƒèÚ'l\√ﬁ≈∆oŒ¯®Ÿ3mÛˆ@ƒÈÕöus'§é∫Í›’P¨^≤˜‡·ÉÈõﬂ¸`ôÛ+Êoks®¨-ﬂ$™kIh˝ ∞¯à¥N¿Ü\s ûØMwx©dDî√pjù„Q>:]•>¯`˙Œ˜?ô~x]/!¨º|NÁ8z›L8X~68f˝s=ÛÈ~:#ƒ√˝Ò@«Z»úÀO«„S	8ª∑?õ„ΩZùém;o›ûäû”‹úÀ6?˚∞ùONÌq™¸Œ¶∂G∆·Íß˘Ó⁄$πÁ˚ÖÊ=G<—9≤=M'πÁÉCèq3¡Æ´¸Ñ6‹O”È ˛Xœfslûª„ì∫ÜÛÖ∑Ö◊Õtj¿EûS∑ÕrÏŸÊã3ÔKØV}⁄Âø*Ω=Ω+l¢ª9“VõülfOíg)ÂîS}ÁSﬁYŒ˝Içx‚g±•%œvsWﬂ~≥ümds"∏ÙŒ∑Û7é<ŒrÔg˘Kã);€ª2uoQaﬂ≠‚ˆD„Ûó˚È[?Ûsgòƒ¥˙	ÿ›∑˝;O,ì÷°SÈ]º˝ú∏´ÛÑù,Ô¯⁄NÀ;·ÙÌΩé	Éì6»ëV⁄â]ÁıòëÔÔfÿòÎ[úbwú#‹=∏äã°¨–ï‘Å|óF=ÉtÕ{ﬂ£^áÛË¿À∏ë—ò¸æ”Ì⁄Ûàw—qù©±´°û=~4˝_ˇ√ÔNøˆÉõNŒùb¢íN 0	èˇlé¥9Â;ﬁõÅwsÖcÈsgbùõS<E2åÕŸµÌŸ•3ÂŸCÜ°”ÒIßühL®c∫£«`qö÷ªù6õÌIÓ… g˛Ô(€ÊÍw´Û”Ò~9?îŸÓó˙6˚Õ›ır: q]ª:NulA{+üÛO3çŸ≥f¸\¿t°∑π´ºú¯õèèAcøùr`Ò†<”ÒﬁÊ∏ÆéuŒÁ∑K˘≠xì.érâÔIAÑºBﬁ•Ó„9ıu<?…}‰yÊIuÃf˜Ê†◊ZØá„ÌÕÚWãÈ€ö∫=û_œø€muñØóÛ´%ﬂR¶ﬁ pwºùoÁ|”’ÌÙ˙[?7ΩˇØˇ˜Œ:}	(ô[R˛‘ÈÏ:¢<Nœ+¶|]]§Ô¯‚ù[«0ß√ÕOéãƒ¸ö›JÈ;	5Ç◊sß?ÙÎ£%•]çåÊ◊áœ≈J»Z‘öÊﬁ·v{∑è\ïq4§—…€(5)k‚^fj»È&JΩñÆ±;ô∫¿∑∆{¢ô‰ØÙÒ7ﬁõ˛Oˇ≥?{ˆ‹ñÀÁ2MAñƒ”HÓ¥√´„—ç¨ì€˘·5HöSR©Á#µKÍ∞º-ø)ˇ⁄uÚ¿‘Å‘¶D:2Â}^F˛”ŸrÚôKíÉ„ö^í<#üMºíéÛ·I;æRÍ¸%…ÁÂí=“á∫`‡>Àk¸Mz˘√¬∆t^«⁄Gu≠lR;ÎXFÉî
Z⁄Ï†Y3Ì–ˆvÂgé¥cØ“nÓµß“ÆˆÀ≈´´„4¿<õPÃ‹≠~RDßòµîñ ‚.çæJ©∑ê¯eπ.xCÒ~¿¸ZWGzÆ•„Ô—£Gëè$oÁ‹k†Î<–;ßI4Tvîú_èº;^GŒµp]ÍúøììÅu≠.œ3™«œ=P•<NØ´Øìì≤ïü4”,≈ö¨ûØìª≥’Àéå”¢æxèùjóõX—ÈÂ€Y”˝%>Iô;ù$Ã∫Ñ~«óí⁄î*øoZ·Úã$¸∑ÅSøŒg—P–öÎ˝fÈÅWπæy3?}[S∑7Àî«ÚÇΩÛÜJé∑÷XÜ)1©ƒÁ2÷ »ΩéQ#8ÕÆ±◊úÁ˝úÂ\txø6‚)È&7Û$9F†ô ™ûël.íg‡¨√À•îÓy›Iç‰Lˆy	xy˛Q˚$P|€:∫2n+Ù|
à¡*—Í@—ı7¢—Ÿ¢ÄÁ§üh•„NæÑeN£ZjùoÚzgã©ﬁƒÔu∂î0“yg“uÈE_|–ÎÍ:_DæŸ°kgùW ‚vªªZæÚ˜Q-0›ŒØÜò+8¸Ìv&.®ìXj∏ƒ»\IË’%Ö8=FÂ˝Jè#—q I ‹5À$cÍú…ÎÓú Âßú#æúèT_'õ“fsyÄw=∞.Áµ„)M°)yo,ÒÂ6îûJ=˚ÆŒ5]ã∑=óù◊:£<I…~MñÔdM‡⁄˘ÈPÓ˙ıMKnãno©øüÓy˝ﬁé©Õhá,«•Ú◊-1PW›?:ºq#ﬁlÚ»Æ√®‘∂nø|ìéÛÊ~Ì~Î6≠Q§ ‘há/K–õh’T}œGSIùL;1{˝ÊzJı^ªπ¿ÌtjT*ôä”õ\5ÿ•Ù∞™ dπv∑£Àó“@∆|ó Ø'*˜“†‘Åà‰Â=wpñˇ‚≈ıÙè˛≥œß77–«qÀ¡Ì|<g^ ú˛ïÃ€˘≥ÙÛ‚Úˆé«›a*ˆﬂ˙ìÔOﬂzˇ·Yùıa,}Ô™séŒâí<…±®∑˙-ÉÆó˙˙VwßQG¢I^|;i⁄>ü¿>9ã◊›Ÿe'ÎT€ß)Æ4]©cß£‰`IŸüNªì’Èt˙v~\_£cÍ#—Èó˘»kßó+—pô¥?©#‘ÒºvœÈ§Nô”H◊y≠K∫ﬂœjÌÁf~5…•„Ú◊óıQΩ⁄ÏxµÏ¯‰∑ÌÍOqÄŒßıí¸:Æx≤õÂjyı√´WØOk.ü∫UÍz ]∫ª_‹ÃøıY‹EÓ˚Aâ†‘=AÂ—ô8WÏıw ó¿ÀÛ&yym‰¯k◊TÁ?{=˝ï˜Wßﬂ˚tyï”t∑˜möTFóJ”4mÓœyŒÔ}¯Ï·ÙˇwˇÕÈO¸ÙÚ]˚œ?ˇ|6özÅÆÎ,\ÁWÈíıÍ¨Í¸¡~0}¸Ò«˜÷´‡Íz2dwTÁ=ÈŸÛ$Zû÷Ä°≥ÀJæ€à◊ºº◊ìËédÔ¯wY»O™££ì¿µ”7Å–óÅö◊Ω˛N/âü¯SÊÑk<ètöÙü∞≥E?ˆÛŒˆ*•ı4““ÓÓ‰ö¶◊áA»ÓÍÈ|ÆA∆˘:]ñ◊”Ôˇz∫zzzˇõfno∑gü*ØNmï´s=˜’av“I∏]ı§∑”“£ÆW7µ»$¶”ﬁr]nRÃÚVÁ‰—‹3øΩô7ãûÚxWæ—›Û`ñÈô∫9SoDº•2l ª-ÇêÎˇ˘ÎüÇ—+ƒ"Èv‚ŒföŒTø9V‚yø‹˚Ù´7”ø˜~0˝Ô˛Áø4_.#˙÷∑æu†(ÁHoJ]ßÁ:˙Í´ØÊ7˝:≠ƒáÎ–ys`aYøOGı3N”È$ô+çuΩ8Øâ∂€w∏:»§2â∂ÉíÎ1 ßÔ2u2ãg˛:o£†Lù9}?vrÒ2<˜2…ßG`üÆSÁ1µmáckÄﬁ·RwÔæ.ˆ””wOz±6qü:®bﬂ¸¯—açÁ—ªıÜÚ≈Êµ%ºwbk◊›»_]Wªá—ÏVØ˛ﬂœØ™Qíøíbô÷÷âdêZªææô>˚ÏÛÈ√æqö~JFôó¬•)ü∫Ò∆g√¯5@ÍıÎû”ItùoK‚Aı›‹£Õ∆Œ—ŒY†⁄ﬂùÛòÓvGÓœÇ‘ÎÎV:˛ı_ˇıÈ{ﬂ˚ﬁlÈ/˝•”¸±Æ∑w $õÔHsù≥m¶)£È$ïŸH≤«ë˝§˙0/)/>;pMºìyÅïÁ%ç0ËgÓ3^&ç :s?HÄ⁄©5`¶lI.øØ<ÆüK 8ïÒ≤¥Û$w“C‚üø#~-ÂlÏ:ﬂπÃÒõGuo⁄D€©<ıÍ†O~Ù˝Èg~ˆ€SÌ˝˙’Ÿ⁄“®Õè˝>ÀoÎ√Hµn¥|¬|3O›TÉË‹+£Ç}GE™ÙÓöˆ≥oé—ÙÍ–3ˇË0]ò(—!®È‹Ô´lß w"œÔŒìé©ì$Fé6‚Êe…ºêYuõÛ`4MßœÈö˛&^ﬂü”9ï€GÄ÷µ_˘ï_ô˛¬_¯”?˚gˇl˙„oú}®ë :“KP ª}πìuÌñh±|‚¡ßö;=∞~ÂI)ïq˛ '9Y.—ÍÄn‰¸ºØ<æÉÆ˘¥Ö:È0Õ2å⁄Ãu†¸^ø€@%_B2©⁄A“O≤EÁCÁ¸ÌdIuxπQ>^c=#˛«∫ªTæP3]€#\‹Â;ﬁtö~Íßøy¿Â3ö‚W~ﬂ·æò|íÈÙ†lçÑû>©˘√ÕÙ¸ÂãÈ’ıõ 7Á@ÌäÏ∂b'•U‰≠m‰/^º^û?[0ú¶isÆXï˜Ä‡'›seú]˘d¨ﬁònÑ<N Ì˘¸û◊}GcØå,5ù+lZ⁄K«˚c˛ÕtN„¨»›¬≤Éd•’⁄Œ/˝“/ÕSz˝Øˇı…˘÷ãÎ~˝ÈÎ¡~M«ıÁüI©[ÿı˚‰%˝IVs
“q`}@∫ßºnè…˛∞1˘B/ØìßÆ0:hw¿úÚ¯5ÁçOıSGù˝≤¸(±ç<u:‹4Å⁄òßNNKÚ2ﬂ(–uı$LpπXw˜õ ª=&æRõ∏≠.Ö¶9©ø»PØ∫Ω}s<‹Ãü1Ø∑Û€EÓ>∏Á;\ì˝\ívUÒº«|SﬂLﬂÕkIµ™¥≥ÕzJWI€˛*%©∞yùÍ0zÚ¯—È£Oæs˛KŒy<⁄°‚Ù’ìKwIùÆÙK‰ËØªv,=ˇ˚g~·õ”ø˙ã+∑^s¸WW'[^ZÓ>˘z˙˛ìﬂúñY¿˝Ÿ)œ≤áZ◊˘áˇNıØ˛’9¸Õø˘7g—Üó“ıwæÛù”‹±Î¢K?˚≥?{Z/Z≥Á+]cΩkAƒ”®sìl'•d;ÈÿÀ§›#{˜‡Á4R Ò{	0\ó>U ˙ìΩ3oßó›ÈviƒìÛœÎÃÀ4≤ØKâÎ! Îº8 ≥ætØ.;È§ÎÆ„Nv◊çÛÔºjâ¯Æ)ª€€*3ÕÀ-€Ì√È«?z5Ωˇ¡!.<ÿŒo˙°åiΩì¸8Ø∫∂´RÌ≤´ó÷÷T_à™?V82¨ı¢√Ì˝^ú7$À§t	ÿP‡é.îÂ“N≥4Ö‚y)–∫ûv&Ø]çjñ:æ˜…O¶Woñ›/õÈnÙz‰ƒ<›+ùøySÛ√”Ÿ(Àµ¬∂≠@ÙÁˇ¸üü~Ù£Møı[ø5˝©?ıßŒÊâ+ï±÷ËiøﬂØ)€öth¨ﬁ^∞©=;õIˆël‘yÙÎâˆÙ∆„.ê^≤C‘Ô9 ß˚]^ß˛;<‡9˝¥E€ÎK6ê¯]ì+Ò‰4›˜ò«ÎK~öÚßuÀxXñõ•|›&ïu˛ª∂K)aHî:y”Œ„d˚Ÿñ`$|∫~}=èöﬁ\¸x˚‡l¥œg¢Ót≥lf#ˇ©Æ]£JW≥ÇèK•¥"RºoÔ˜í∫îz`û™ª™©ªÔ1Âòû€`0d˘î∫@@uﬁ…”h7ì'ÈÔSΩ N'ùéz´ˇø¯Í’Ù≈Û◊wë1k>–ãLy^oAﬁoêwÉR–5U˜O˛…?ô75¸¬/¸¬Ù…'üúûMc{ÈÂâ]‡Ë÷2</ÎßSß∂s˝•4®®um∫ñoƒÂ“1iQñ¥"‹&ª	 ª¿¿‰æ∆NõÛëxÎ‰M~∫	3ùw[¸=±˛dèI7…«5*HÅ«”(‡éÚ$[“ı¥y¬ÒÅuÌõ €mRÒ_&—¯Ï”óÛt‹”wv˜Ï⁄imwo¶èæUÎHuÌÆ^æ√n	Lõ9é\_o¶GèÖA˜wå™Æ˘9§´zìÍæÇ“BË¶ ßgªù7êÈN)-<ÕLÏoU˘‘&	>⁄)ív÷âßìhw◊ΩRÉ'˙#¿H ëú¯‹17wFt˜ÀÂÂûÄb≥‹ﬂÔÔ2úŒ≠‹~ƒ`ˇg˛Ãüôæ˘ÕoŒÜı´ø˙´ßQRM◊âW˝˙9i•`›9€§+…3Hoì®:ﬁaË -lûéˆàGÊ≠îfk‡úxaæn◊`AÍ(Âóè˛ﬂµIö s~um‹∫ÄìÍ·ÂsõÍl`DœÀÒö◊ÂzÒ2‰Øìs˛—’„È¡É∫vÎæ´{ò¬ØÈ˙€yÎ∑⁄´~˝%	µk{ªπ:BŒÅ∆<ËÈﬂ¥æ€‘úae= –√±zïPΩj€7◊ØAÈ·Èßb®W{À%î+e
äwgrê)15|R∞Áq^:PYÑŒ˘;'ıÈ¿5Ωodd¢Zg3›-›ÉéŒO\·◊ÀLT”Ùpwˇ›]‘g§:Æ5$:7yN∆›µG~,Áˆ∞f^ÔËór¶iã(FÁâ?N2éh(ﬂ®>ÊKu≤lÚ!ﬁs{t><è€Ä⁄´RØ=€{ç?ûÛπ&ó/’ì∞BΩÛÓ±éë˛GˆËX»{ûØ£ù∞tTg*”a§˚¬˘Ò~zˆ^ù/ÿ·£[-/Ÿ‘∫Wﬂ5™w™k˛rƒv{zπÍ®±ÂQÈπéÔÎñ|Ì^æ~5=}\ëÒ—≤Ω˜∫ÇŒıÙxÛ@‰—Û†38< Ø≠√%î∂îw‡„ N‡Áâ@”õ$x|æ~O«S2ﬁd,æ-R¡›iT˛Á_˚p˙‡Ÿn˙Ï´7”2"öá8,”r}˛b44´Ä≈)ºÛ|OÜÒóˇÕoûÍ-æ ®¯5Õ‰ùÏ©≠:áÛÙ≈_L~¯·©\zñMuK_Áã≠”=;JN¨{ï“s`.ã€Ür‚ÕÈ(x%ªM¡¿yI)Ò’Ò!›r`§“„Ωƒõ2Ôß)y“vûºû‘ﬁI>ØÀy"M¶n™^ºy9ÁÕÀ$K<çt“—ı¸I'âá$´ÎV≤ñÔiÕ[ﬂHR0b˝uØ0^æ∫›ÚzÁ6_¥Â◊s {Ù·ºkbŸ
º¨=<yÚd!Õ_ß‹ﬁΩ˛ÅﬂΩ–Æ;ﬂ ·ï±,QØ®†‚“˘(uŒïÄ≠3∫T_j¸Óû”HeR‡e‡S†R–˙ÖèüL˚ˇoMˇ‡ˇˇÈt}sÌú…2›]´zNÁ«:OwÔ˛≠kµ\¯Øˇ‚{”øÒ'ﬁ;ÒÛço|c˙Ï≥œÓ=wF˝RﬂIØû◊¡´+Û˛˚Ôüç∂u_∫Xá‘÷§IyYog¨œi2?Ø%L¥:{rùy¢mßÎ‰¡u¿˚˛6◊nçKÂUé:ÏÇÉÉjjßƒ∑íèl:–vêu=ÓWÇ';å>
ÏC
TÃÔ6ùRƒ“Ωd≥¨«ÎMÌòÙÃ:Ñ›
F¬+çí§´:W^M›y|H≤…ˆ™‹n{åÇáûuΩ`ı…aTt}s==∫zp¶∏ÍÕ÷ßµãÄ¶ËùB¸Xçñî‚JOø.îóÒÜËîﬂ9i‚πÎ]u’Ò◊Ò¢—#Û¸©ü}:˝Èü{gXÆ3§ƒk⁄$¢<’Æ<ÁËñt\∑»uNﬁ]Ô‰Sôh˚:€±.â~ßßõl~dù<	‰úñ|%-xªRbŸŒO◊ /ŸX‚•ÛuˇÕnw≠”ﬁÔ˚ëÿ‰ím2È’È≈–ŒWßÉTˇHœæû≈<π;-^K;~…c«Kß∑œ™ØÓk*NõÑ[ï¯&óJI•Øãßcùœ:ZF9õ˘9ìZCö	ÕC¨Û-‡Ôæ˚Óô Æ∏‰$ı<Áô%ï£Úd Nî¿íÂ:Åôóºß ¬≤âøÆúÀìúï4ÍØæÛñŒù/◊˝%‡X…r$j´n[≤◊ØªR{;üûó¥úóÆé0í-±nwﬁ.Ë$^…O:Ôl4Å	È&ôI€ı%¨ªµ3Í/…‰«ûíØv<%ﬂu∫ÚiTîé˜M` ¨YÅ—ÏÀx=~1u¯¥∆üÀ1¬∆˝~<íJy¸◊€^Å¶˛4Í©§—;n8uO3fﬁV.gßßyWû±û>}z‹öΩTÚ˙Õ´˘wï^ï¸ŸO∫^4Ué—3Ì|q sÊGuuÄÁÏ;w6!@¯1Øq>õ<'∞ÚD„OFZ¡˚”O?=ÈvRIIñƒGHÁ+©ÆìéØÅ•ˆJòF»˚&hv«|#`|	Ùõ‹ı¥fÛﬁùû®9/˚&¯&æx?ïs;]%∞ÅoßèéüúS ÏÄò˘dG\õÌh∞˛˛áßeá§Ø≥[WNˆÿ˘˘ŸìÎ!ÈÃÂcﬁ∏ç	7÷âÒÁà:ª™TN˜'úKr*Q∑ı7©∂Ê>8>[2g‹\Œóiªª≈©ÌŸ.ªnwŸó…ØØãØwÙèûúg*ÿeHñhÒÿöAπ˛jÿ[o?ØwÚ≠π»ª~;ù9.ü'ø;`'Ø◊E=•˙:]W∫<(ùå∫ì-—V0tÒ∂Ë¶E(gá£ºî!ïy›¶2	XG¥íç:ü£≤óÿH«üÂàøK“ö}T™v’®Âcuﬂßñ¶ålj‘∆§Á…uNzŒª∑ix9¶—ˆ˘‘÷Úá
2ÀóŒÒ Î“ß'ÙÚ §5%∆	ü&uπvµ´^¥?•€ÕqWÀú„|óã‚ÊÑN…q≈à*ñ†d()…')¥k][{¿nDÉÜL>ú«K >˝zCi.∂ÙSé√˙ùﬂë.:„M:wÁÍ Ìõ`( O:Ne∫˙/ü‡£|…∂:ïd+