'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.default = diffSequence;
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

// This diff-sequences package implements the linear space variation in
// An O(ND) Difference Algorithm and Its Variations by Eugene W. Myers

// Relationship in notation between Myers paper and this package:
// A is a
// N is aLength, aEnd - aStart, and so on
// x is aIndex, aFirst, aLast, and so on
// B is b
// M is bLength, bEnd - bStart, and so on
// y is bIndex, bFirst, bLast, and so on
// Î” = N - M is negative of baDeltaLength = bLength - aLength
// D is d
// k is kF
// k + Î” is kF = kR - baDeltaLength
// V is aIndexesF or aIndexesR (see comment below about Indexes type)
// index intervals [1, N] and [1, M] are [0, aLength) and [0, bLength)
// starting point in forward direction (0, 0) is (-1, -1)
// starting point in reverse direction (N + 1, M + 1) is (aLength, bLength)

// The â€œedit graphâ€ for sequences a and b corresponds to items:
// in a on the horizontal axis
// in b on the vertical axis
//
// Given a-coordinate of a point in a diagonal, you can compute b-coordinate.
//
// Forward diagonals kF:
// zero diagonal intersects top left corner
// positive diagonals intersect top edge
// negative diagonals insersect left edge
//
// Reverse diagonals kR:
// zero diagonal intersects bottom right corner
// positive diagonals intersect right edge
// negative diagonals intersect bottom edge

// The graph contains a directed acyclic graph of edges:
// horizontal: delete an item from a
// vertical: insert an item from b
// diagonal: common item in a and b
//
// The algorithm solves dual problems in the graph analogy:
// Find longest common subsequence: path with maximum number of diagonal edges
// Find shortest edit script: path with minimum number of non-diagonal edges

// Input callback function compares items at indexes in the sequences.

// Output callback function receives the number of adjacent items
// and starting indexes of each common subsequence.
// Either original functions or wrapped to swap indexes if graph is transposed.
// Indexes in sequence a of last point of forward or reverse paths in graph.
// Myers algorithm indexes by diagonal k which for negative is bad deopt in V8.
// This package indexes by iF and iR which are greater than or equal to zero.
// and also updates the index arrays in place to cut memory in half.
// kF = 2 * iF - d
// kR = d - 2 * iR
// Division of index intervals in sequences a and b at the middle change.
// Invariant: intervals do not have common items at the start or end.
const pkg = 'diff-sequences'; // for error messages
const NOT_YET_SET = 0; // small int instead of undefined to avoid deopt in V8

// Return the number of common items that follow in forward direction.
// The length of what Myers paper calls a â€œsnakeâ€ in a forward path.
const countCommonItemsF = (aIndex, aEnd, bIndex, bEnd, isCommon) => {
  let nCommon = 0;
  while (aIndex < aEnd && bIndex < bEnd && isCommon(aIndex, bIndex)) {
    aIndex += 1;
    bIndex += 1;
    nCommon += 1;
  }
  return nCommon;
};

// Return the number of common items that precede in reverse direction.
// The length of what Myers paper calls a â€œsnakeâ€ in a reverse path.
const countCommonItemsR = (aStart, aIndex, bStart, bIndex, isCommon) => {
  let nCommon = 0;
  while (aStart <= aIndex && bStart <= bIndex && isCommon(aIndex, bIndex)) {
    aIndex -= 1;
    bIndex -= 1;
    nCommon += 1;
  }
  return nCommon;
};

// A simple function to extend forward paths from (d - 1) to d changes
// when forward and reverse paths cannot yet overlap.
const extendPathsF = (
  d,
  aEnd,
  bEnd,
  bF,
  isCommon,
  aIndexesF,
  iMaxF // return the value because optimization might decrease it
) => {
  // Unroll the first iteration.
  let iF = 0;
  let kF = -d; // kF = 2 * iF - d
  let aFirst = aIndexesF[iF]; // in first iteration always insert
  let aIndexPrev1 = aFirst; // prev value of [iF - 1] in next iteration
  aIndexesF[iF] += countCommonItemsF(
    aFirst + 1,
    aEnd,
    bF + aFirst - kF + 1,
    bEnd,
    isCommon
  );

  // Optimization: skip diagonals in which paths cannot ever overlap.
  const nF = d < iMaxF ? d : iMaxF;

  // The diagonals kF are odd when d is odd and even when d is even.
  for (iF += 1, kF += 2; iF <= nF; iF += 1, kF += 2) {
    // To get first point of path segment, move one change in forward direction
    // from last point of previous path segment in an adjacent diagonal.
    // In last possible iteration when iF === d and kF === d always delete.
    if (iF !== d && aIndexPrev1 < aIndexesF[iF]) {
      aFirst = aIndexesF[iF]; // vertical to insert from b
    } else {
      aFirst = aIndexPrev1 + 1; // horizontal to delete from a

      if (aEnd <= aFirst) {
        // Optimization: delete moved past right of graph.
        return iF - 1;
      }
    }

    // To get last point of path segment, move along diagonal of common items.
    aIndexPrev1 = aIndexesF[iF];
    aIndexesF[iF] =
      aFirst +
      countCommonItemsF(aFirst + 1, aEnd, bF + aFirst - kF + 1, bEnd, isCommon);
  }
  return iMaxF;
};

// A simple function to extend reverse paths from (d - 1) to d changes
// when reverse and forward paths cannot yet overlap.
const extendPathsR = (
  d,
  aStart,
  bStart,
  bR,
  isCommon,
  aIndexesR,
  iMaxR // return the value because optimization might decrease it
) => {
  // Unroll the first iteration.
  let iR = 0;
  let kR = d; // kR = d - 2 * iR
  let aFirst = aIndexesR[iR]; // in first iteration always insert
  let aIndexPrev1 = aFirst; // prev value of [iR - 1] in next iteration
  aIndexesR[iR] -= countCommonItemsR(
    aStart,
    aFirst - 1,
    bStart,
    bR + aFirst - kR - 1,
    isCommon
  );

  // Optimization: skip diagonals in which paths cannot ever overlap.
  const nR = d < iMaxR ? d : iMaxR;

  // The diagonals kR are odd when d is odd and even when d is even.
  for (iR += 1, kR -= 2; iR <= nR; iR += 1, kR -= 2) {
    // To get first point of path segment, move one change in reverse direction
    // from last point of previous path segment in an adjacent diagonal.
    // In last possible iteration when iR === d and kR === -d always delete.
    if (iR !== d && aIndexesR[iR] < aIndexPrev1) {
      aFirst = aIndexesR[iR]; // vertical to insert from b
    } else {
      aFirst = aIndexPrev1 - 1; // horizontal to delete from a

      if (aFirst < aStart) {
        // Optimization: delete moved past left of graph.
        return iR - 1;
      }
    }

    // To get last point of path segment, move along diagonal of common items.
    aIndexPrev1 = aIndexesR[iR];
    aIndexesR[iR] =
      aFirst -
      countCommonItemsR(
        aStart,
        aFirst - 1,
        bStart,
        bR + aFirst - kR - 1,
        isCommon
      );
  }
  return iMaxR;
};

// A complete function to extend forward paths from (d - 1) to d changes.
// Return true if a path overlaps reverse path of (d - 1) changes in its diagonal.
const extendOverlappablePathsF = (
  d,
  aStart,
  aEnd,
  bStart,
  bEnd,
  isCommon,
  aIndexesF,
  iMaxF,
  aIndexesR,
  iMaxR,
  division // update prop values if return true
) => {
  const bF = bStart - aStart; // bIndex = bF + aIndex - kF
  const aLength = aEnd - aStart;
  const bLength = bEnd - bStart;
  const baDeltaLength = bLength - aLength; // kF = kR - baDeltaLength

  // Range of diagonals in which forward and reverse paths might overlap.
  const kMinOverlapF = -baDeltaLength - (d - 1); // -(d - 1) <= kR
  const kMaxOverlapF = -baDeltaLength + (d - 1); // kR <= (d - 1)

  let aIndexPrev1 = NOT_YET_SET; // prev value of [iF - 1] in next iteration

  // Optimization: skip diagonals in which paths cannot ever overlap.
  const nF = d < iMaxF ? d : iMaxF;

  // The diagonals kF = 2 * iF - d are odd when d is odd and even when d is even.
  for (let iF = 0, kF = -d; iF <= nF; iF += 1, kF += 2) {
    // To get first point of path segment, move one change in forward direction
    // from last point of previous path segment in an adjacent diagonal.
    // In first iteration when iF === 0 and kF === -d always insert.
    // In last possible iteration when iF === d and kF === d always delete.
    const insert = iF === 0 || (iF !== d && aIndexPrev1 < aIndexesF[iF]);
    const aLastPrev = insert ? aIndexesF[iF] : aIndexPrev1;
    const aFirst = insert
      ? aLastPrev // vertical to insert from b
      : aLastPrev + 1; // horizontal to delete from a

    // To get last point of path segment, move along diagonal of common items.
    const bFirst = bF + aFirst - kF;
    const nCommonF = countCommonItemsF(
      aFirst + 1,
      aEnd,
      bFirst + 1,
      bEnd,
      isCommon
    );
    const aLast = aFirst + nCommonF;
    aIndexPrev1 = aIndexesF[iF];
    aIndexesF[iF] = aLast;
    if (kMinOverlapF <= kF && kF <= kMaxOverlapF) {
      // Solve for iR of reverse path with (d - 1) changes in diagonal kF:
      // kR = kF + baDeltaLength
      // kR = (d - 1) - 2 * iR
      const iR = (d - 1 - (kF + baDeltaLength)) / 2;

      // If this forward path overlaps the reverse path in this diagonal,
      // then this is the middle change of the index intervals.
      if (iR <= iMaxR && aIndexesR[iR] - 1 <= aLast) {
        // Unlike the Myers algorithm which finds only the middle â€œsnakeâ€
        // this package can find two common subsequences per division.
        // Last point of previous path segment is on an adjacent diagonal.
        const bLastPrev = bF + aLastPrev - (insert ? kF + 1 : kF - 1);

        // Because of invariant that intervals preceding the middle change
        // cannot have common items at the end,
        // move in reverse direction along a diagonal of common items.
        const nCommonR = countCommonItemsR(
          aStart,
          aLastPrev,
          bStart,
          bLastPrev,
          isCommon
        );
        const aIndexPrevFirst = aLastPrev - nCommonR;
        const bIndexPrevFirst = bLastPrev - nCommonR;
        const aEndPreceding = aIndexPrevFirst + 1;
        const bEndPreceding = bIndexPrevFirst + 1;
        division.nChangePreceding = d - 1;
        if (d - 1 === aEndPreceding + bEndPreceding - aStart - bStart) {
          // Optimization: number of preceding changes in forward direction
          // is equal to number of items in preceding interval,
          // therefore it cannot contain any common items.
          division.aEndPreceding = aStart;
          division.bEndPreceding = bStart;
        } else {
          division.aEndPreceding = aEndPreceding;
          division.bEndPreceding = bEndPreceding;
        }
        division.nCommonPreceding = nCommonR;
        if (nCommonR !== 0) {
          division.aCommonPreceding = aEndPreceding;
          division.bCommonPreceding = bEndPreceding;
        }
        division.nCommonFollowing = nCommonF;
        if (nCommonF !== 0) {
          division.aCommonFollowing = aFirst + 1;
          division.bCommonFollowing = bFirst + 1;
        }
        const aStartFollowing = aLast + 1;
        const bStartFollowing = bFirst + nCommonF + 1;
        division.nChangeFollowing = d - 1;
        if (d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {
          // Optimization: number of changes in reverse direction
          // is equal to number of items in following interval,
          // therefore it cannot contain any common items.
          division.aStartFollowing = aEnd;
          division.bStartFollowing = bEnd;
        } else {
          division.aStartFollowing = aStartFollowing;
          division.bStartFollowing = bStartFollowing;
        }
        return true;
      }
    }
  }
  return false;
};

// A complete function to extend reverse paths from (d - 1) to d changes.
// Return true if a path overlaps forward path of d changes in its diagonal.
const extendOverlappablePathsR = (
  d,
  aStart,
  aEnd,
  bStart,
  bEnd,
  isCommon,
  aIndexesF,
  iMaxF,
  aIndexesR,
  iMaxR,
  division // update prop values if return true
) => {
  const bR = bEnd - aEnd; // bIndex = bR + aIndex - kR
  const aLength = aEnd - aStart;
  const bLength = bEnd - bStart;
  const baDeltaLength = bLength - aLength; // kR = kF + baDeltaLength

  // Range of diagonals in which forward and reverse paths might overlap.
  const kMinOverlapR = baDeltaLength - d; // -d <= kF
  const kMaxOverlapR = baDeltaLength + d; // kF <= d

  let aIndexPrev1 = NOT_YET_SET; // prev value of [iR - 1] in next iteration

  // Optimization: skip diagonals in which paths cannot ever overlap.
  const nR = d < iMaxR ? d : iMaxR;

  // The diagonals kR = d - 2 * iR are odd when d is odd and even when d is even.
  for (let iR = 0, kR = d; iR <= nR; iR += 1, kR -= 2) {
    // To get first point of path segment, move one change in reverse direction
    // from last point of previous path segment in an adjacent diagonal.
    // In first iteration when iR === 0 and kR === d always insert.
    // In last possible iteration when iR === d and kR === -d always delete.
    const insert = iR === 0 || (iR !== d && aIndexesR[iR] < aIndexPrev1);
    const aLastPrev = insert ? aIndexesR[iR] : aIndexPrev1;
    const aFirst = insert
      ? aLastPrev // vertical to insert from b
      : aLastPrev - 1; // horizontal to delete from a

    // To get last point of path segment, move along diagonal of common items.
    const bFirst = bR + aFirst - kR;
    const nCommonR = countCommonItemsR(
      aStart,
      aFirst - 1,
      bStart,
      bFirst - 1,
      isCommon
    );
    const aLast = aFirst - nCommonR;
    aIndexPrev1 = aIndexesR[iR];
    aIndexesR[iR] = aLast;
    if (kMinOverlapR <= kR && kR <= kMaxOverlapR) {
      // Solve for iF of forward path with d changes in diagonal kR:
      // kF = kR - baDeltaLength
      // kF = 2 * iF - d
      const iF = (d + (kR - baDeltaLength)) / 2;

      // If this reverse path overlaps the forward path in this diagonal,
      // then this is a middle change of the index intervals.
      if (iF <= iMaxF && aLast - 1 <= aIndexesF[iF]) {
        const bLast = bFirst - nCommonR;
        division.nChangePreceding = d;
        if (d === aLast + bLast - aStart - bStart) {
          // Optimization: number of changes in reverse direction
          // is equal to number of items in preceding interval,
          // therefore it cannot contain any common items.
          division.aEndPreceding = aStart;
          division.bEndPreceding = bStart;
        } else {
          division.aEndPreceding = aLast;
          division.bEndPreceding = bLast;
        }
        division.nCommonPreceding = nCommonR;
        if (nCommonR !== 0) {
          // The last point of reverse path segment is start of common subsequence.
          division.aCommonPreceding = aLast;
          division.bCommonPreceding = bLast;
        }
        division.nChangeFollowing = d - 1;
        if (d === 1) {
          // There is no previous path segment.
          division.nCommonFollowing = 0;
          division.aStartFollowing = aEnd;
          division.bStartFollowing = bEnd;
        } else {
          // Unlike the Myers algorithm which finds only the middle â€œsnakeâ€
          // this package can find two common subsequences per division.
          // Last point of previous path segment is on an adjacent diagonal.
          const bLastPrev = bR + aLastPrev - (insert ? kR - 1 : kR + 1);

          // Because of invariant that intervals following the middle change
          // cannot have common items at the start,
          // move in forward direction along a diagonal of common items.
          const nCommonF = countCommonItemsF(
            aLastPrev,
            aEnd,
            bLastPrev,
            bEnd,
            isCommon
          );
          division.nCommonFollowing = nCommonF;
          if (nCommonF !== 0) {
            // The last point of reverse path segment is start of common subsequence.
            division.aCommonFollowing = aLastPrev;
            division.bCommonFollowing = bLastPrev;
          }
          const aStartFollowing = aLastPrev + nCommonF; // aFirstPrev
          const bStartFollowing = bLastPrev + nCommonF; // bFirstPrev

          if (d - 1 === aEnd + bEnd - aStartFolloàúñ¿@o~ã;4FP"¼Å>^¶yçø^Åv1ˆ+ ãÅvq=ÜÈ^Š@Eæğ"X~c…NGOûîÃ}NÎÃò”œERäFÙéP‹o¥bõ£ŠÕ¦±oMãun¼w+z]ù} `ckÁİX5Ï#Gòx}9‘¥q]qõ,®4 1ÌWW™Â¸‡ìˆœO0ÖGó,‚ñZ©;0s%N%0÷{Ö:“c¹A·Z‰7zÍ*ÆW²ÊïÄ¼x$˜À†×Ú
0WèÜµ§yì|ëŞå<²r
gË¨–,–ƒñ8¶•ˆV7dõ ™9ĞNŠ…•œÆ‹ËXVªĞã²Í8q¼¶{èĞÃºGLA|^ŒmÈõx¨µAœ«GHÔÒ“—ÏÒŞ½Éq§OmCE\b—âÊ0‚K'SÀeßßŸ±0ÚôÕKYsÌ‰„âÊníx5áîşÖ7éõh„?WºV†OÒ§¾ğúäO–Şúáët7z÷>ˆãÃa,Pt\Àç<Î‹ç-xÔ‘ñòìÅËt5Š×¸?_`Š	‚}§S«nÆº}õÍwéa¼Æöùt)‚ÛË—.G§U\é9ÍÍuZ¶Mâ»ó‡Xá{#®ôíÑù3ÛtæüEºxí‰¸Âw–µ¡İ>ÿüóüNat‚bUéªóÖÖO÷ææft&ğñûûû<†à™qöaõğ?Ö=àÙ¡µlîïÓÉ]AÀ"€_vn÷óvÚeäkHc` ¼¿1ğè2Ğ#J÷şàY¸Íå=B¢™|€$í[«6ót3Öêõ6‰Å 2‰ö¶èÂé)×·bÑd'zÚîÇeú1v€¿àTÖ}%ñöÈdª‡(!. 'j'“
²r\ç¢úË
X¤Œ­Â#­Wùns	°Ï´7ÚœXïE0‚‰…õ‹©eÏŞÁqœd [Lì	à¿4+ÉşÉÜO^åèx±â=ƒ$©rå«ršûgqã%ñJÊc¯OôŒ•¶ãÍK+õ]©g”¡ÛKrš¤›8(‹¤c"¯\NøTKòñ°%+É Â¬®"{[œôW…×>àß^9í’ªÀÆUºÌé%AKRqÒŞ9Ã¤aŠ›HÅª Ë¨Ñj}$÷•¾·½l¬ú}xù±½^U6z×¿lêÄSBùŸ²Ïè$•üóÃ`(9]H¸èduRå˜d:ãÕ!ûÌ „òÀKñA¼ò—’«rs^–yK˜ô.¸T§^3‘˜ÊÁ+RzõåïĞÁş.™õÕ5BO^==[ÛÌãÎLÁp…ÚÁÎÃCº}‡nÜ½O÷ãç6‚Œõ„ ²L´BAPêæK¦¢>o4â>§hKkÆÿô+_©9$E‰`ëŞİ»Ü†Şxıud:¨ãÏZœØ'³†%Æ¼fñ„[y@m5Ãeà`4Ò2â5®h+Åà>2ãb–*d§‚à¬i2Ÿ4ÅZñ4¨A­c¨–/(7¨‘cmO‚{mâ¤ G>Û(ÿ@¼ÚàjûÙTWÆLéÄ±‚ÈôxN÷ß½MçŸ]*Å` Y]áYçv$ã]&9íƒ5S.@gª#hÙ¾xÏnpÜÊ(®HøÑP<«¬»å³¸"xæ<=÷â'èÆ×ÿByçññ=ÃyÒ ‰[ü<  q¸±M»±M€§çÆnâx·òØµ‹L98œÊjâ\4ì½o8Xq9h‹˜4pI‘îcœ}ûæ]Ÿ¡c}js#n£´’àTj–ãeâgÄğ¼ÑÈ èâıØxpÓÕÀÅ…`<–ã°z;è’ÖY2»¶ê=Aoc=oÈ0ÎdE¶æD; ™íã`ÈmzQ…š=¤<7Î^eÊËÎÁD³H»$wÉür'²‚¨“ Yşö£ÑµW š8G`QkVßÖ1€~™[ä†„Ø ˆÇ*ûZk ØÌIvÕàUı‰Ÿšöc=|÷õwè\ô€CşÌémÚ:µÅt"ÌgÇ3´×hô¬ÙèÃãÛß˜WYZÖYG2%âëèT°ëÑ8«Ø X¥KÏ¼Àq÷#¸EÛ°GÑx©éÉ£§?ô°³¡Œ~ÁÔ
@ÿ qU«l`Aç½®Å„÷3UçZÃIÁ¦tïÁ½ıæ[Øpõ±Ç¸ŞïÄvy->×'ŸŠÙ<¦Lxå÷ÿ-ığû¯Ğ÷¾ÿf¼îŒ._<KOGCõúOÓ§şÎ/ÒcO}HÎº›91ëZHæ	7/;ş>şøãéóz4ñÀßØØˆÎ±±J~Y¬ß<[-0tæ.‚L› } LÜ;¯¼ğò£NZİ¼.“&Mz0¼hp¹å%u¼M2ùø<?,"a \xèã¢m=v„C:wzÆzÃP‡˜îÒáÃÛD{;4^[ç	§Ò€hã 6'@N J+AV]ÌSc3OÉ\“=±"p.Rq5s°Ù"5<@?S2ÉANÃÛÌÈ8ºÍ¼ÑÉO´‡á½ƒ%,å¶Á$÷‚ì¿Ã«‡Î<‰`…­òè’œ³¦{ü÷qDè‡sÎnw'Òı È“­ÄëEÙV¬d¥Ótë!·	ó§ÛT_i ïuÆ‹ïZåJĞE<©¶ì!Ñ”×šHd>‰ŞÍyÍ´Y×h
z©ÁA‘…ámU°Á8¤ÌVÆøW±·]¨1„º2`I³Ñ¨ÖÀSõ,âıTØÓR¿ÓerÕh7j”xø+ö»¾jC¡'n®÷9'†Ûı#·Gö™°xPèL…)lƒ”Á²?.ñ1&E›]_+ 3ŸF°>˜KûC²4åÔÒÜ‡èé¦^-ÿ«+´qê2íîí[¼Œ\Ç¥â³gOó-gœ4,(UC$Ùæqµ¨Šmúò®œ¥ó§ÖèáÁ!½ùŞİè-ÛÓ4.ïnÓµ¸Ä»2ô:eyİ±7ıµwïÄåşy\I’„k±Onm®p¹ ’ír&mĞô¸‰²PL¼jyƒ÷9S5Y1’öCœÕ5´Ê2Ö4R¯T¥ßJ-·E)C‹í1àÔƒÎ6³äÔÃÒpQ#Ú±~•Æİwš”GÕ3‚rÆ[¡{qr“Ó&¬DQÔ½¯T#É¢éR’'\oDrt{·ïÑúÙmZƒJÅ°fÀ(@E®İª’K«ĞE0ö1W›ÇÙ­>CÃµ1§•‡ëTÆdR;b¯&úa½å×>ş	:¼y‡fÑ@ãóáé¬E‰à{¼yŠ†›Û±ílĞäí÷8ı÷Q¼Î!8ÚñàEÛ¹tşŒ¤}Êİ‡y­¯Äw8¥Ğ°,Ï†¤k‘Å;¥bw÷ˆnŞyÀ†¼sp¼¹0µÒ³Zb"{ÊÉyö ¢$n­¯ÒZ<Æ#¥Mfì=…G8ÌÕaÁ2’–­TAÙSÜ¢í±€6©HbÎ¾`ô9n["{;àxÄ*Aw}sû­Ÿ:Oû“×øş¦s€9ÁÇI²–67Öh/:Næ{sb«<§¡OrÖÙx“ãÙ±ÈÃHô¦aNbĞ9Ç4J”*™G*vèxáAG£¡bÙÎš3áBµdg÷€%7cù/;GÛãªÇ#Ë`ÚJ,ãşá,{Ñ ß¥ûñïññœÁş.¢'ù¹¨ó~‘'-m¯èê¹³¨Ãğšòqû±¿Ÿ^²á}8w8‚’®Ş‰Á€Õ¦PÍıy.ÇŠ].ıàûÍwnĞ_|û»S2ŠáÅËWéÂ¥´û‘3[ôÜWãsùÎŒ€zş½ûÛô­?ÿúŞ+?Œãà”~é#OpıÅ[·é»¯¼ÉŞéwŞ~“şáoıtíñ§¨;Ü6øàT(ãËy'qÿÑŸ±ªŸôç²SjÎJó÷òüÿĞ·Ú<W]\* ÃQ±´ØÁå2¢n®ğŒ½ß|ÌàÁ¹4`wœw! ùZ\º·•“·[v›î9cštâyË~³¥Xê^Š·¶!Ë4ñoğİ?>ßx´ZÓ­ûçéø°¢+—w"h‹—8@·vr¸Cû÷o±õ:†çM8§f€	«xUe²óš2™Øbl½€7ö¼Æ¥Ó–;±g‘µ~ÁÕ‹K³şŸ‡É$,^€~Rà-L–À(¸ñ¤¡ry°Yó$>Š×Ä0CkœÎ™zÅútØÌë•A>hV=ó¾ƒ×ËÉkIƒó&Ì?ÄRÔ^ò ¾¦½Ìf:<'dšMñƒø|ŞÏûœ]z˜DåŸu^KŒ²VN)$A=Nè‚f@¨L,fÆTbI8!(Ø¥g…òÖÙ[õºh6¢O;QĞ$ÏÔ²‡6dZÇÁf“´Àã¶ºf\v¡ÀD aN$X’ñğ² 83ÄQ2k+vêm: Ü©V¼hÚªØ¼í¾RšL[D´³†‚Wı-•È-ù\ìê|‹À=eäÍVj‘/Ôß*Oë¯÷Vó¤Í5âÍcnå”ßãp¸Æ  ıüßû"÷‰{wnÒ™³çb³i0Ği°,ÏKÚ øìq^'¨Ÿ ˜-{6‚°³Úäì•·vvè­wé•¸ü{şô)zâò9Z‹ÀgvÔĞÙ¸ ôê›7éöÎ!{±]ôÏ]:KgÏlpû|¸»CGq²1‚gº½pHÀ‰ÂãÉŒƒïíL4I™Ô«Ó±w r…\s&¶1ÿ—óÓ¨>7%„9áOÛ ßc?k½ÊOÊ1’Q3+HiãvÈï(p"1â½%d
¼å= ír<L‹O^>C/\;Ëgğ¤XNÂã]#T•PI ßÜKJ!x;G^Ûö,zón¾ş=ë^<gâéeã€Ò‹sáX³<›*ÄˆCciô(Fïöz\šßËÿ A†›Û£‘®ÎU*K7ŠŞæ‹~†nşÅw´_IÀåpc“Ö â7NQ—ö±¬°sï^t*Ep6eĞƒ®‡Äõë#È²Î8t¯§³–ßï&¨+^2s°¥Î“˜Göft÷Ş.İŠÍµÊà<ujÇO¤Lgj"ÆQæb¦!èsVÑX–½‡<¨mm­Òfü·º±ÎZè -Íğº·óîŞ½CGûGÑ)r$Ün Y’´æ¢”#šğó ÓìB²PpœŒë'@’Œ¯<îÖ@?ğ5¯2BÚñôå'â<µF·nïqá˜A› ÆÜ à<™ãU:ñ®oon²³¦÷X m#NÜ8Ò¬³çÛ‰¡f>&q®€VYñŠJ›óDP&’
<ñ¦Á¯V-~¨ÈÔ.®êÆêÚßxŞ»û ZÒ†'g5ÓU ¨•0ô>Îß³ƒ}Y™‹$ªbÀÀº¿w@;±Í®Ä•–oüÏ¿Kï¼ú2İyóyúÔ§?IO^¹LÕx(+Şëªçw$«.")m\úã4Ö1VYö£‘wÿÁ.½üıÒ·¿ó]Û>úÑÒg¿ğ…Ø‡êˆ3Ö¸A=~å"íìíÓ|í;ô›Ÿÿ)>Şöÿÿûïè¿û—ÿıúO?Nß;: ÿÃ¯~>óÉc™6èËüeúWôUúÒÿùÿô_Òùù¿Òz4â¸>A7šLø:y[ÄmË$šû¿-ÛJ¸%tšÑ¸é%P/¿—ÛÄw‚0ƒZ±æ™Ğ½Ä€(ôà¨+ùÓDYÊ/Ÿ³l+qÖí^<Fo‘vK‹Adİ=Âû˜a¡¬æËÉŸåcÈÆ\:ñĞ)Gß«­…Ô¥šuRwª”:vÄÕ:.#¦wo8:ş˜ÆõL¤ã`²ºyF@(À]ìàä&<ñ‚e«Ê‰µ½d¯V+­$x™ËóñDã…Gç¥M3şH:nâ4Ğì]·F\I’xNX•¥½„kÍKı”c®†[#¥N'd$_	ğRéó"ê~ÆfÍÉcÔ@i%‰.·Ë$qmgëh-~Ş’	H3&ö–©0²´	# áÀIR3‰ d:•à;€ğ)ƒöV½î!‚åøúĞÖãïSb$(/BqJfsk^%Tİƒ¼¦{—g¯dRÃ Î^'“/qëóKò§VŸÛŒ3ÇÉ-À=Hq.uç5iˆˆñíE®‘ƒP%ğtÀI’ˆ?sâ$ö°‹×}4vìÇ±ÃüåµxD9°ÕşÔ"—‚Ò¼zÛ½UYÙÄeÃ4Ù§ïC"K˜Û-Ùù—İÂ	ßµ·İcÚ%Wà¯Ÿa5­ãàõ'Ÿ¡ÿÍÿñŸ	ÿ|éÙ”5§Á›=Š“êq‰Ó¸ÏÓh$G×şÁ.ó´ v±Kh3WÎD¯xô†Ş‹Kæ·ï?¤o}ï®OÑÙ8ñ ¯Ç¥ëÇ®œe¼E7ïîÒè={÷öNìë5{(áÍ¬5)‹Â6´Z¯Ğæ¸â@¥{À=÷å2µd­•¬%¡Ÿ0ÕLû]“Vªôy×Äds'10Z	òfUoöôÙZtŸ^¸ê AœooFû‰ºE.nmÒ‡Ÿ¾BÏ?q)Ç4Ù‰†vì¿V[‰KõŞÚœÆ\„jÊc@¯¨„˜N4â2şÁáíÜ¹Gg._ã±ºÖ8	N÷$”öL)“õËj8¢SO>I;÷,·ñİÃˆ¸fŠÉà˜Oãbı_¼Lûïİ¤ùş÷%d•G`XGà]Wx•ñğázpûNl'Ñ#W7 Ec Ò×¶7¨‰û±B’”ŸPƒŞûHèéJ„a†•Û±]Ü‰u´½¤WÏoÇ¥úU­ùJÇ~ÇŞJÏ§’f:?ŠíSLPäVW¡æ1ŠKş«ÑÁ³Çˆ!{ç{ÛğÃøüîÜ‰íjÆÛŠ•’JC[Ë¡ ´šÊ“dQh¢»À«FPÔãmÎM¤åq”¨Ÿ ®äŞî!__”[¼:{Ô¡¥Vbxe6~F 4h( ‚Ôq¯­ÄÕV8ê–¬ŠTÌÀILÊ7ô’„iæpâñnÅ$ğ¿aˆ0·¿a-y$€‚¢Êöé³Ì-G{?}ê4+®L'P²s¬B°gqÃó(Mt®`Íù÷—i¬_äÎXCPRì_Û¯ÒêÖ9î:7Şz‹¾Ç—ÏŸcNö*V(¢Qù­ø®ğŞ`˜y ½:à{‡Şg@YÃÛ·îÇ²Ó•«Wèâ•«ô0nï>8¤'`Ø#ókôî|í•Ğë·ÒÅÓ[Ì·ù‡¯¾Jÿïÿö_ÅûoĞßÛ§KgÎqpüN\9ñq.Å½0ÁĞØ‹ãÖƒÌÛ6 àİ4Mw¬-€nø N›Gã>ó@^rñ;/;xËk.çåçîwéSÙ²bæ“Ëø²‡w Úß–[%2t–¥.À}ÿê¥4y§isÉ3˜ÇŞu0r(/ñÁîµ´Tañs$-$oK¸¿æñîıNÔâe-±‡:‚ÎSÑr?>Go¼½=moDµ>’Tæ­è¯ÖSÉ¸ØÌ§êm=Œ“,éñR±zì\
ÄtiM\Îd²p^Ó4³…nYÑøys%ù‹P0¨J&´Fh¹<I5dF‹$’—ä5ƒa ÑõuqP·å}1dæ)1—7§ZgbâşŠÇ‹*™¨2ñ~	De°‹uN’ŒVö¸°§Qú†«—›”F–Í9¢œ5R£WêzËÇñû”E;&“†Aùáñœ¹À›Î" MÅ ^ø&Ôl$ÙC`/»WØ¡Ö¸¶#ñŸ‰[6$Õƒ2œˆ„W r§àÂA&UÔÔüØ¥Õ(§uİvV¨êê%šãÀSö˜# ”¹ìB‘}vGãá¸3ufD¬İÎßá]:õşXB%ÏÁS•%RĞ6%Ê2šùw×:^å¼xŸuîş@˜úšëuÅLw~èwPú`Û²s);!N¸Şh ++«:#é{-Ê§ÏĞpB£Ø¢àTÁ:£ÀAs¯DOmˆ“7@4”!,äÌ¹3ôÃ7Ş¡ï¿}‡Ş¹µC§·à	]• >¦‰!Æb’TôÎ9€St“'³¹ô]'ƒşÀy^2‡Çv®)ï®Ä4ŒGì¡Ì)\5üE'¾3˜©ó¦­fØt²üM”A¶]û}›¨DVÍ8ÍŸ~æ*}ü©ëÑƒ‹8˜"&/	ÁÃèmâsù±ÄŠÀáĞV•N¬ûR0<?éxè½¸Ò°ğpu$œ ÜYÔt¨$ å5ƒ—ËãØZAº.®¢l]{"ö·CºùŠxY),3.§»Q4ªÎ=ó=øÁËÑ E¯÷¯b2Wt¾8˜¼ó/ÑŞßá€ÍËñ>£8Æc9ùßİ}Íé\<şÊµ‹4ŠFÃn¬ï›ï¼1•Ò†SAöÙë
t>÷ËÎp²)ñ|ÅcÀ&2øİ62Ş¢?£¾‡Ñq³ÿ|¡]KÏ÷ahŸ
#pl<¸s—vîŞæ
3ôÃaº`,4Ç\¨Ñr+¥/É6"ÿÈtªcE¸­¬ª€ºå¹G`2´Ñ¼uáq–Ä¼¹{À«H÷>P„åWeíEá†$
·Öü¬m\yÜm¥‰ÒŒ”zØÚªŒŒ…ğ 7ApK£ÚóPÂ÷8mæd²Â–W™8	  †
ë¡¼ƒ“Ã®Í‰=[æªÁmNšèv‡JŒu^â,¤cÖkxÿn«k±mã»Ü¢ã§Ÿ¡½¿óñòÇqF0äIß_[Õøşl˜ QK ¢ıÁ(„G;®„ŒF"µg{3¾ßÇ}–Ö6·¢aƒï~ÌcÙîqC¯¿ı6İŞ…Ø‹ |­Ğÿşîw¾M÷nß¢ë/<Ç––~ö#/DC`“îGcó8¾ˆ7ïìÄ²HŒÅá‘ä+Àø&CDà¸ÃiwïŞeµ'…‚Ó}*®øÁéƒö÷A¼ÏÆøQ6—ûNĞ÷½Nád]Êe>Ï İ<ñ'Ñbìswõ¾Ë@?á×.t]lß¿bíÈ´õ
äzWùÑ€øûOİêD¢¾i’Áu¼‰’‡'×§Y_¡sW3~‚zm9(Ès„ÛQ´æVhçÆ­ÄÉw?¢cÑtu²üÄƒ¶¬‹Á&NÍ|¢aÇ6ôlùnåÏ^ x¿ğ@Ğÿæe¬Jhšd€A±z€„ïm’N!Õ—]ÉªŞ$İƒ¥´œ×A=fœ~|	®è†²çS£*–XÀ!*«v5[ÍLué”“ÆDqs ’–Å”_„öRk}‹·¸b«I0œ ó j)|ï¦IÉ`œySTk]øïX…”Ó¹P–9*ÄœK ö PG‡ûa~t ğî™w‹:ÌÌqài3¯•S3ßµáAºæ|wºjÁÀ¤í,×¥“tŞ°x#EŸ»Õìnóä-âR7ÄÁ}ÓcĞbL]†Ä3Ï`$c¬z·½P*×ˆÉ±3 ÄŒVÄ³À ¿ºêØÛ^;¼ït5N³œç5ø4g=³ôÎBQÎ¾&gà¨xo«”¹L;ÉÃ^s~ÔbÙz÷
½±Oû:áh…ÿ­u/¯ádì ¯Õâ8Ä°€}ëæmæ‘Xò-.©O¢—ı0z×#(}ïİqyy‡¹³x {m»ÃåÙ‹àAĞƒ
zËÜS¸­C|S¡Ê;hµ­¹ec[M¬„§*ß'ØÛ'oHglNé_›¼OD(nôpzÿÎ'§/üôÇdÃh#™2*x65Ë+ÅçœJëŞ’6&¼jÕ6šPÀ=h7Ş¹I×Ÿ}Läü8ó#V§j‰#ÄŒH~ÈÍcöÊb¬9óÄ³´Ò,®fpì?ßŒin­ÖzÚÆåk¼úçÀUŞØâ`L€o´ëİ÷Ş£Ûß~‰VQÿğ9ğ"‹ˆr –SiÁØxk;ş;Oç.§Õèq¼ñİïpÕ‚ópï€Ş‰Ëıø½~ñlßÛ\Óù”ç“9¯¤à3·€Åñ~«AŒ€m´¶&AzñyÀ@Á ¢E"3xü%f\‰}!z”ˆyûî}¼”xÎÀm†ctâØÌAÿâÀØ)úßâ‘…šõØk»ğ²R0Ï«¦pî «òöiZÛ:Kb;Ø=:æ1Ñ€0§o¥½pqµ¢ãßA?Y_§û³]N€„¤MÑkíppêYL ?T© Paæ­Ğ™ 8ª$É*Ğ»Ç*SÒèŞñ­Äç\‰FÜh¬ÇR2Óˆæ¡®xníìİ œ»\ÅósğyN<’X${Š²½h”¼úöÍh<¬ÓÊù1¯ÌnoŸ¢—.Ç÷{LÛgNÓ¹xß5NÔø™Ä±T*Ÿ	gdğ‰Ì©cN7ä ÌÀ~{ôÊko’¿\ó<†õê3gÏÒF¼¨B¯F#.Äö=sÃXwâ¤»ÿQøë¯¿Æmşôæ*½ùÆ{t*²××èáşŠ¯Kqõî•·Ş‹«#ÚİoèÊ¥‹qÿ‚ƒ!ÑqñÒƒ_ùÊWXüñÇ§ÍèÍ_+¿ò+¿ºàqÚ«Kçîî>äñ
(?
Uä/ÚõÄ…YÄğ}&²Ñ¯K™îïrË”.r.<Py_(/2 ë>Î	¥ŞÑ½aúƒmiÔ&ZVç.ı‡–E±O¾Eï‹:h:“j(~+îx¿Ó¾ò¸¹	WÜGÏ5 ìVıÑ*½}²O»´¾²O[[óØÙâÀ76æVõ±}ôªI xâğĞÌ÷ˆiÿšîİU’E2‘‰—[˜93Éøª`uF9ı·x¼yÙX#ÏÙØH@©æÁÜ’iÌ:_¬iæ©Í¼(+İ²ä8(¨osÙ$#é’³¯X{÷(N#œ²j i¸káü¶ìñÖêDêéúÛ\¯1Ï¨2²¡Må1¢±ÇC2æÅÉ_ò&kP«jØFğÜÌ¼rÃGÔn6¤d|²t\Æ’1U%ZIb1å@¦Ë9AŞuÈ6càŸ	Mq^ ÊÀÃz_Q<ìÊofc£’•miBk’I…ŸT2xœ6î65Mfò†ÏØ~×
8?RZ¶ç¶˜<­½hwÏ@]2ãqÃ@äÖkõ´ÔámW¯{=”ïì‰g¯šU=¼ñÒÆ;do»w¨{ï{^K:S„ıQËÜ'9^¸÷ùş·°ëàÂÆ¢iÑë†àë-H{9=5sd0y.«7¬H4a¯úÃ]ÚÛÛc¥ƒİ‡qI>N\àPûxì¨^.´ÚaÀ#K'–s¦³ö\M8]»ôox!Y‚¯œrõx§ô†Û—çqÖø[YµáL¥Aƒ&+Õ'Ğ4/Ä	ücşP\v?KÍ=Nnşµ‡Ôîƒ7îŞ£•è!„B	iIÔ‘h:;öh7Ç)½F´ß}÷&]xü"VDm¢òj¦"×Úês'$€élsxQÇL#«V6éÂ3/ĞÍï	Ç»B4œÅ³õ[ËŠbĞ«/ÇşºOÕxUú(b÷÷è½o~‡\Q –pò]€!À@jµ”õèG«$:OÆñs½B§Ï]¢wİK<f<|¸OïŞz½–ÇôìãWèÂö&¿#pÿ‘aqï,<ò@‡Zûğ˜r²›á€ï0ŸÜÉØH¨3DúĞ^l7Ü“19>¤ï R9y¦ğFéLl»ÇçÀSÉd(^pÑ‘?šÀ½øxØ áşTÏÚA+|•Î]y‚é:7nßáö‡qÎ»o¼Fo½úJ4,æl®‰BËxãNÂ3Æ{Er)×e5«NXEAVSS¡Bªw‰ñ0CSâ— ş3™ÁÂ´ÚÇF5ÑÃ;§í6' ³{Ñ{Aæª®F´Ñ³%ÑÈìå&í“NUDêF¤õø¾X½fÍñËU,ÛÛ{ñóë7èã§iè°2 ç¯_¤ßùï‡v# o¯]}d›6¢±´µ¾"Ê*Yµa@ëqq0 tşF ì^ìó¯½õ&g½xı’ˆ;@İ'–+À±¬%Àû0<x/—c›²Œ›Ø ÿèpÂô8N\®Òæå³´sóuº¿¿KÏ<ÿa^±{õµ·èêãODP-î†2e}6zá¡ëıS?õSôÜsÏÑ¿øÿ‚f7gü÷WõWèÆ›±¯¾KÏÄ•$ÈîF«	O=õıîïşzñÅé‰'Ç\Š(6Ş£İÂÛkÇ¾b‡–iŞ÷¿êÖÙT~în	*(¬¦íãä…;Ø…Ã‚aó”%¦éPA’··œÍÌƒú#LXø~ôqh.Ë×›Hû`|a®Õâ¹âsÏ±£Å
ÅëSL¬^”æ›.ê½^”@xc’%mV^YE`ÊF\®YVêt%öîÄâi}m;"8‰ñß@Àë(N˜X±”„ĞcâÇ›3]¶ÈÔã8G¤ –ÙK.TNKìE§šÇUÖ!×I.YJi•Úö¬Ì qqm­š×b÷…v€±Y„Á–îªV4xU‹WŒx˜5)…sYmğ,ÆšÂsUyˆ`¼êéOk á®ŠZ© åtšš=áXŸÏXÙ¶m-åpPïò@Ş¾8Ğ*½DeYŞ/m@“dr"½§*&’î[±7H’œHdwÃïhÎtÒLgsækb‚…;<FH„1pDıáÑŒƒNæ®cI üóÌco™"Şu§£á®‹ÊEî¯†'ÄQ)J06¸xmû&“ÈÁzAø˜B± Tšƒ=ëæÑP/¸‚jÎÎê2ÿ|8>b‰Gñ ÃÃ¾¢\v–É~¦È„F»Ğ^”Ç^{M’ä3åE–|eúÉ.µ=æ´{5?Ì©ìcå:Áû‚ô¿Ì¶Ì«/@'(˜jü˜CDêoÀmÓğ›Lzg.^MÎ3À Z<ëBÏh$Wìşƒ:¨1àm"» ¼Èö	_äAÜ¿¿‹u|F²¬ò€ZÃïV8åà‘û`ó:,…Lë_<èŞâSâAÏ¦ÓXóêM%Î•}ÎY»”¨k'za·/œ£ÕS§ÄÓÚJ2“¦ÃyØ*$±ÏF
¶;tëİ»tõ©ÇUİbÎ@»ŠZ… ²ôsâ(Ç<Ä6²zö"mFcfïİ·ãø*ÚÛ’´ÇKŒŒ×„e«›ìeuf”ÇûÜüÎK´÷Ö[¬pq¨b¥šxîP®ƒ ¼rĞØC›†n<É*‚ØğnÆå~€Ğ<s¶·¢w7‚ò}öŠxãyW×F´Pµ&B€^\ÃIVLø·}Ğ_8GC¼œ;q¥¼yÌEç¯\¦»GÏl¯³!6ŸÎx¬‚ \tÀã{JP2yîQ©KdlÙ¤’ƒ[âø4’2WÊ<dçÆtîú3èßº¿Ïõ;íì/şìË´wÿ.w“§Tbcª"~èÆÂXd½{¬*D0È±ÃëN×ñ‚!ç¤«ñ;è3>3äp¡óJĞcÈ
¶ì8Y¯FbğÂH›2sUª‚¦BŒuŞH–Z3I&Œç¤œ» Èf¸Fß¿{@Í÷Ş ?y•ÖÇ6/œ¡=ÿıÁÿò%ºõú«qU`3–y•V™º1b5­‘ÊIBÕètì+Cyß!ˆáãûK_şúû¿ñ›4^ßŒm`Ìöî¬á9T%$hÚ ÊcX%XíñÔÚJgúT½ßúó/ÑÀÍ™.t;øŸFäÑÑCº±·KûåÏÑÎ™÷h¯¹A¿üK?E¿ük)ÚI»sç}ä#á±‰x~ã7~ƒ^{í5nw·oßf€şçöçLP†c ‰zŞŠı ş÷~ï÷èêÕ«ôÒK/±aóË¿üË,gˆñêûßÿ~ÄEktíúuúÚ×¾Æ† ¼üê¯ş*Gãwş‡ß¡.Ğç?ÿy‘–ìeú,=Ühc ¢?ŠÇıı¶zéµÊy¦ğ€/izr^ş'WxqCï¢åuÂC şıºÜ!ó¬KNi„‡„+à(Ayß 9Áè Ê×0ï·İ@Í•Ôä§K–¢ämg@£á
CÀë T×ã€¨ÕÀ¶èşÁ”ƒ¾¨= õQ\n[ŸÄA,Zw«ëò>:øf¢¡pÈ•º2ğŒe@à¶if
¤%TªUï2²½‰\X¶fyùXLZp³1Ñ$¯¨[-/ï’€ÍŞÙê}²åÒ
 k$4OÌüìr-¤>'èT}ÉªeºLÍş`úŞÕÅbkÔ$’f^—ÔXnÑ[PgHtf6‘w$Ò&éµ1¥GƒQXP~ì£67&‘"t™SR€ÅIzëº–>c@ƒ½ÿÊÍÇ’(ËJj"%ŞóV3›¶IUFV¼¶Áœ\	çÁÒg¹°ÙŒu†8ãwxÖ«*Îã¾†i1P™Ì‘|ºlğ¨ƒCÁïVV