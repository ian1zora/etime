/**
 * URI.js
 *
 * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
 * @see http://github.com/garycourt/uri-js
 */
/**
 * Copyright 2011 Gary Court. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 *    1. Redistributions of source code must retain the above copyright notice, this list of
 *       conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
 *       of conditions and the following disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are those of the
 * authors and should not be interpreted as representing official policies, either expressed
 * or implied, of Gary Court.
 */
import URI_PROTOCOL from "./regexps-uri";
import IRI_PROTOCOL from "./regexps-iri";
import punycode from "punycode";
import { toUpperCase, typeOf, assign } from "./util";
export const SCHEMES = {};
export function pctEncChar(chr) {
    const c = chr.charCodeAt(0);
    let e;
    if (c < 16)
        e = "%0" + c.toString(16).toUpperCase();
    else if (c < 128)
        e = "%" + c.toString(16).toUpperCase();
    else if (c < 2048)
        e = "%" + ((c >> 6) | 192).toString(16).toUpperCase() + "%" + ((c & 63) | 128).toString(16).toUpperCase();
    else
        e = "%" + ((c >> 12) | 224).toString(16).toUpperCase() + "%" + (((c >> 6) & 63) | 128).toString(16).toUpperCase() + "%" + ((c & 63) | 128).toString(16).toUpperCase();
    return e;
}
export function pctDecChars(str) {
    let newStr = "";
    let i = 0;
    const il = str.length;
    while (i < il) {
        const c = parseInt(str.substr(i + 1, 2), 16);
        if (c < 128) {
            newStr += String.fromCharCode(c);
            i += 3;
        }
        else if (c >= 194 && c < 224) {
            if ((il - i) >= 6) {
                const c2 = parseInt(str.substr(i + 4, 2), 16);
                newStr += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
            }
            else {
                newStr += str.substr(i, 6);
            }
            i += 6;
        }
        else if (c >= 224) {
            if ((il - i) >= 9) {
                const c2 = parseInt(str.substr(i + 4, 2), 16);
                const c3 = parseInt(str.substr(i + 7, 2), 16);
                newStr += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
            }
            else {
                newStr += str.substr(i, 9);
            }
            i += 9;
        }
        else {
            newStr += str.substr(i, 3);
            i += 3;
        }
    }
    return newStr;
}
function _normalizeComponentEncoding(components, protocol) {
    function decodeUnreserved(str) {
        const decStr = pctDecChars(str);
        return (!decStr.match(protocol.UNRESERVED) ? str : decStr);
    }
    if (components.scheme)
        components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, "");
    if (components.userinfo !== undefined)
        components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.host !== undefined)
        components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.path !== undefined)
        components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace((components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME), pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.query !== undefined)
        components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.fragment !== undefined)
        components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    return components;
}
;
function _stripLeadingZeros(str) {
    return str.replace(/^0*(.*)/, "$1") || "0";
}
function _normalizeIPv4(host, protocol) {
    const matches = host.match(protocol.IPV4ADDRESS) || [];
    const [, address] = matches;
    if (address) {
        return address.split(".").map(_stripLeadingZeros).join(".");
    }
    else {
        return host;
    }
}
function _normalizeIPv6(host, protocol) {
    const matches = host.match(protocol.IPV6ADDRESS) || [];
    const [, address, zone] = matches;
    if (address) {
        const [last, first] = address.toLowerCase().split('::').reverse();
        const firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
        const lastFields = last.split(":").map(_stripLeadingZeros);
        const isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
        const fieldCount = isLastFieldIPv4Address ? 7 : 8;
        const lastFieldsStart = lastFields.length - fieldCount;
        const fields = Array(fieldCount);
        for (let x = 0; x < fieldCount; ++x) {
            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';
        }
        if (isLastFieldIPv4Address) {
            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
        }
        const allZeroFields = fields.reduce((acc, field, index) => {
            if (!field || field === "0") {
                const lastLongest = acc[acc.length - 1];
                if (lastLongest && lastLongest.index + lastLongest.length === index) {
                    lastLongest.length++;
                }
                else {
                    acc.push({ index, length: 1 });
                }
            }
            return acc;
        }, []);
        const longestZeroFields = allZeroFields.sort((a, b) => b.length - a.length)[0];
        let newHost;
        if (longestZeroFields && longestZeroFields.length > 1) {
            const newFirst = fields.slice(0, longestZeroFields.index);
            const newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
            newHost = newFirst.join(":") + "::" + newLast.join(":");
        }
        else {
            newHost = fields.join(":");
        }
        if (zone) {
            newHost += "%" + zone;
        }
        return newHost;
    }
    else {
        return host;
    }
}
const URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
const NO_MATCH_IS_UNDEFINED = ("").match(/(){0}/)[1] === undefined;
export function parse(uriString, options = {}) {
    const components = {};
    const protocol = (options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL);
    if (options.reference === "suffix")
        uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
    const matches = uriString.match(URI_PARSE);
    if (matches) {
        if (NO_MATCH_IS_UNDEFINED) {
            //store each component
            components.scheme = matches[1];
            components.userinfo = matches[3];
            components.host = matches[4];
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = matches[7];
            components.fragment = matches[8];
            //fix port number
            if (isNaN(components.port)) {
                components.port = matches[5];
            }
        }
        else { //IE FIX for improper RegExp matching
            //store each component
            components.scheme = matches[1] || undefined;
            components.userinfo = (uriString.indexOf("@") !== -1 ? matches[3] : undefined);
            components.host = (uriString.indexOf("//") !== -1 ? matches[4] : undefined);
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = (uriString.indexOf("?") !== -1 ? matches[7] : undefined);
            components.fragment = (uriString.indexOf("#") !== -1 ? matches[8] : undefined);
            //fix port number
            if (isNaN(components.port)) {
                components.port = (uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : undefined);
            }
        }
        if (components.host) {
            //normalize IP hosts
            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
        }
        //determine reference type
        if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {
            components.reference = "same-document";
        }
        else if (components.scheme === undefined) {
            components.reference = "relative";
        }
        else if (components.fragment === undefined) {
            components.reference = "absolute";
        }
        else {
            components.reference = "uri";
        }
        //check for reference errors
        if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
            components.error = components.error || "URI is not a " + options.reference + " reference.";
        }
        //find scheme handler
        const schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        //check if scheme can't handle IRIs
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            //if host component is a domain name
            if (components.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost))) {
                //convert Unicode IDN -> ASCII IDN
                try {
                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
                }
                catch (e) {
                    components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
                }
            }
            //convert IRI -> URI
            _normalizeComponentEncoding(components, URI_PROTOCOL);
        }
        else {
            //normalize encodings
            _normalizeComponentEncoding(components, protocol);
        }
        //perform scheme specific parsing
        if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(components, options);
        }
    }
    else {
        components.error = components.error || "URI can not be parsed.";
    }
    return components;
}
;
function _recomposeAuthority(components, options) {
    const protocol = (options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL);
    const uriTokens = [];
    if (components.userinfo !== undefined) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
    }
    if (components.host !== undefined) {
        //normalize IP hosts, add brackets and escape zone separator for IPv6
        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, (_, $1, $2) => "[" + $1 + ($2 ? "%25" + $2 : "") + "]"));
    }
    if (typeof components.port === "number" || typeof components.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(components.port));
    }
    return uriTokens.length ? uriTokens.join("") : undefined;
}
;
const RDS1 = /^\.\.?\//;
const RDS2 = /^\/\.(\/|$)/;
const RDS3 = /^\/\.\.(\/|$)/;
const RDS4 = /^\.\.?$/;
const RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
export function removeDotSegments(input) {
    const output = [];
    while (input.length) {
        if (input.match(RDS1)) {
            input = input.replace(RDS1, "");
        }
        else if (input.match(RDS2)) {
            input = input.replace(RDS2, "/");
        }
        else if (input.match(RDS3)) {
            input = input.replace(RDS3, "/");
            output.pop();
        }
        else if (input === "." || input === "..") {
            input = "";
        }
        else {
            const im = input.match(RDS5);
            if (im) {
                const s = im[0];
                input = input.slice(s.length);
                output.push(s);
            }
            else {
                throw new Error("Unexpected dot segment condition");
            }
        }
    }
    return output.join("");
}
;
export function serialize(components, options = {}) {
    const protocol = (options.iri ? IRI_PROTOCOL : URI_PROTOCOL);
    const uriTokens = [];
    //find scheme handler
    const schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
    //perform scheme specific serialization
    if (schemeHandler && schemeHandler.serialize)
        schemeHandler.serialize(components, options);
    if (components.host) {
        //if host component is an IPv6 address
        if (protocol.IPV6ADDRESS.test(components.host)) {
            //TODO: normalize IPv6 address as per RFC 5952
        }
        //if host component is a domain name
        else if (options.domainHost || (schemeHandler && schemeHandler.domainHost)) {
            //convert IDN via punycode
            try {
                components.host = (!options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host));
            }
            catch (e) {
                components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
            }
        }
    }
    //normalize encoding
    _normalizeComponentEncoding(components, protocol);
    if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme);
        uriTokens.push(":");
    }
    const authority = _recomposeAuthority(components, options);
    if (authority !== undefined) {
        if (options.reference !== "suffix") {
            uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
            uriTokens.push("/");
        }
    }
    if (components.path !== undefined) {
        let s = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s = removeDotSegments(s);
        }
        if (authority === undefined) {
            s = s.replace(/^\/\//, "/%2F"); //don't allow the path to start with "//"
        }
        uriTokens.push(s);
    }
    if (components.query !== undefined) {
        uriTokens.push("?");
        uriTokens.push(components.query);
    }
    if (components.fragment !== undefined) {
        uriTokens.push("#");
        uriTokens.push(components.fragment);
    }
    return uriTokens.join(""); //merge tokens into a string
}
;
export function resolveComponents(base, relative, options = {}, skipNormalization) {
    const target = {};
    if (!skipNormalization) {
        base = parse(serialize(base, o' 0(Vm‘Q‘eê2OÅiN
gJ'öDï³¼,·Ê,L~e¾>+-¬ŞÉ²"Ûş3ÙöÅZ>ı^‹%eV*Á:“®æ³2gUÊ,•`÷µazldV`W¼\ÎÊs­Ì	¾vVcÆJâ)™—Ç´h›ç°Ì…öå6K†£µŸ0ãZ@O©p?‡FBüŞ÷÷·‡ÇçÓíß,›åäxñxwoÓ'N—f(P2+³,í_¹oœ,±BÃ0”Y*1d‡»Ì¤( WÊô@:Ú¨À¬œæ«(«T]4ÅğÀ2:÷H€°,”)‡Å¬‰ußÁ²ğ½8f´Œ÷SIëò2–§RQ£¢‚_.É~1Ï˜{‚VîüJØ–ŸÔõÅ?¼rs™®…&£2¤ãº‹Ûı1î·×ñúfo®?ŠÕãØaWLĞ²ı+ß¶V]÷nµÙWòÙ°’÷Êòu5“"ôØô‚1UÖósbÆ5şâƒÿÍí/ÂÿLœ  ˆ˜‘q¢ûáÈÊT™X¡/¯¶ÛtZ]kÛV]©,e<z?gœC]š°8f«aÜZ­¬„Cj ÄhÀs‘aÂçà²‘ûñ<îÑUéëÎ IVŒÌ6G
ÎU`‹Z›@Y'µ,ˆazıF÷‰‚~yÖ:ªØ›ù$µ& '§ 9°y1¹lèeĞ2 &“/7z u¥”Šº$¨ãX²SB[e¹oµVV-Cl9)b/6õÈ·Uæ˜æÕ“PË‘”e†7"-€ƒ«¡Òs É(ûä‘ vIªql§—ÛÍªf›î¯B¢†ûU›Lßõr=TH§ÿ÷éÂG_©VäŸıºs¿¸ÒóÔÙEæ
•e°äÜ´xQ+TkâÔe+¾Ü«?Ü—ÿ¨!€«Ì$Ÿ96RÖò1Ù5š©‚ô÷ˆo(iWì”‘Â©hŸ¯äI»İ@‹ä4¨ L¶Ö¸†N °6)LÌŠ)ñ”QÌOÃ\w`qĞâvŒ( <İ*M®`°ãéñAP`“¬%Ír_à ¶K·ã(¯ÏE¥À
ÿâX¿’3üiMP%/ôöw?û?\_­0)1»ƒŞŞ
»b¬éœaÉZ–ùçåÓòÔ1gLÒ3‹ò·z<‹éßÓ‘f"zÿ`}iQ¬%XYÓÃ–Ø- Õ»»»1+¥Ğ§”÷#‘õ^¾Å°°<0,º,¿XÈyv„áË<çÒaÖ,ècöéƒNoMã6ñõ\Uı f`ÌJå&V€%ìÁ¬È·?C!«ªó¥˜æ¬"ú•˜¢8WÖ¥pëĞ¬½Æ”¾Å³V,UççŒ•¥×[ÌNÉš•Ì¼d7°Fv¾Kn,¦§uM,‡“+œÂ¦ÀÈZ noR–ëk§:·8†usïçÛÊ e	¸ä¢¿Ü×¥ûò yX] ª"L’¿£¨Ø:,·È°Ğ¹L*¢0œ¶É=ÍAÉ|¿æ@f	Ì,­×l‰“û¹0ÑÚè	ñqLiÜ`Ôˆ›ÈÛ>î$ìw´@QÇÅgA(ôñ±‰U¯¶ÆÏcû\«§_÷Š5(g°Q¯³ûŸ“?¨ÁW‹¨&cz­\\\¸Û;#Şùu¯L¥ûğ#)¾ÿåºñ×ëŸËÚ¿ë V Rğ°º¾–u}u\ûVªèUª} FğŒ <y“2<v@íÏ”G™Ñ]wCú˜Bzö¦hÑJ‡ØG˜uşâIJ* ÏEujQjPŞ ktÔˆ0F…;ŠHôù÷jy¦:‡ÈDŠÊ®‘x/ËíäpÚnàgMª58Lƒ—Ï+).ßÖÆR°j÷Ôwào8,A‘sNpy3¬¬+zVÒ`G°·²´†¡u,í,ôÈÔ¼Ë_Ì¼³%M]ÑĞu%Ç·“¡P­%¨k wàÑŞĞ{0€b]`òù"	°·^©+ZG·© Vºz-±¨€BÁ{„=³W·¯U¥#lI»‘"]X…C«)÷|=ÀÈ x†q¶ÇíuĞó!Sı ‚vZ„cŸª¯m}ö°ÈLÑ~€¯ˆkÀyÃgÜ»ïÙ¿Ş)›Äk§UPr<¨3o×”¶|%ar¾ú÷Oê@ôâ×ï¥ÄJMî¥°‡¨ÿøZ6öqÍ•A4
ûÚ(Û×ƒ[}!ßy¿YéµºSq~N×Ü¢åÇ¯À£åé Ì	P]­µUSx9Ì”_1#wf®¡E¸7Äôr@N_ï=	t7r'˜šæ&ºÎ˜°r†~²€'Ïù@aïÍÖZ^óêã†à’l]}2|ÕV_¶}­n 
VşØıä'Z+|öÙg+y4–\oüøÇ¿?~Æ*Ëò6ˆñoG¿Ÿ¯2Êšgşû°<ƒ˜oïx*ïá8÷&<·üÜ¢ø±,òsïşËËË$ fñùhÿû2·,f¦‡\–ìíËìÁ3¼½ôÅè‡]àhmHW{›ÍÊ•æbˆd°’[¾æmj\;“ë¶Æx|®µÈ`¿oì¾—ÙXQŞš“—Î™¯ÙUK$ü¥._ŸÖ×çÙv{nCĞYÁ)CYĞ2RÀ
Ã*åVy)VµŸ+’çmY¥±¾ÓóL2Şr¶º›ZÁ¨gÁnv5Yœì¶¼=µî:Ç®”@ ¼/çp¦ıTË’sZT¿âÉ~4Ğ ¤œnS-Ëü•z´;^:oKû¶´s óĞqbÚûèô}¾¼óµ÷@‰àÚÇ¹´ÛX‚¢P8}YC”îµvoy
XEÏ=g*8˜¡Õ”luÓyóÊ™²€|‰½Õtj"«¥y`#÷%*Áq]¯”¹ÌÓõà‹ş­ï·W‹çlÊ_\ËõüF˜Ø|uq„=Tèd*¹b}„í±¶|0³^õmÃ ­Úº;º®¼¤G¦M&ÆÜ>
ô´&ÍÄÀß~²è%#à´èBÑ6f§îk,œ!"ğa–“©¡WP… Ó·:Š÷Î˜Ã6hj97”¨ß€XëÇ™=bæÜ\¦hk‹Ö/§Ï¹Kj}|°ôqœfìÏ¾ á+A£ZU¥0½Å{Ûtî/×~ù€‹×RC|Töà')KC6 °(F·Ş-n½jJšÀ‡
ôa6p\ñDÓ©«öû„÷1<?8g;³ï•ßR$×ÛJnÙ+$‚šlå#s{İØ5˜®+´†	ğBK´:Ğš@é ¼z¼ zO+µãåë³õ´3ö•9,¢­=[½ÚïşË—nı÷7¸¤\óË-Ûø:A}Ì¤A©ÖLOÑ¿<÷2h\4À"ìù:Ô•YGfø|Ì¤Ôdÿ®¬=íuëÂ‹Z½„ıˆ9\RF—.9ş»•]£Öd£Ì¾¯¾wğMïËG¯ír´²Ö|èO*¹?|.ŸúŸ6®©cµ…Yb~âıöİ@¦ˆ³S¤™Ô\©õx ‚š[5œ`Nú_2IéßZÛ"×ÜâVJ¹–NVmc:ğñörS¥Ëyÿnî½ÇÁ¬ °|ö™ş]€´…å¿üc<ı¡ûW?ü‚®å¤|{Ç³Få=Í,½!çŒ
nË´}•Ë£roÜYŞÉ|l6÷ØÈ®_Ó=Zµ¡0«™¶]†øX.C¦……[Ö©8=Ä.cÙ–xì˜5+:nOô*hıâ>XÙ¡9c%ƒ”¬U9¸\ğã·SëeÌLfÍJ)i8ÊÇX²®e^0g°ÒºÉL«ö¦Ğ>¤?€çûRa‘Ù)ÌÖZ –¬Wqcâ=n
©
?Ç¬èOõ¤/† êYˆå	HA|£»‡<X>fÁ’y}U<)ÊD…îäñı*Ïíœm97J½J^éõŸòµ×5³Ñ[c€Ä-–óæÚeÀe4@¥èU~Ï’&)‰ö¼!ùq÷ÜX¸|9–óQÃT£¢?•İêv9ÇL!‹î›×©z; ¤œãŠjü®¾£N%„?~ñ…²(Ûm=²)ßûÌşø¡LjC×ÕAƒ#û€ü:~!4ÅR` "?Ğ¨”XËù
G·¡5¬9jõ©§ú“Î\Ét´‘àµÖµ´¢3
E™Ü‡¶00!(Ò©e9¶,²²Ş£Lcë…ûßA@Et¿’C»•ÇÀT Ğw­ºâùGÙã7²³-Ú‰dy0<tœbæŠwïĞâ$ûÙtJh¢}¢ôšîP‘3êØ§®b‘lÃ~×ºcÛóøv‡…}T0ĞÉzÁÆè); 0¸»¨-ppH8ÀóQP=·P€yšÔàÌ[{™a±Œ”óı±§Sªk<qR€ï:™í—mìî˜4ÏdD~Lå.®j)Ôk×¡íé	–v·=Gµ0µ,÷V^Ü^^V Òœp2tpÛ€Y¸^¸†ár„€®`rŒî\¡UìO…*ø«­2 ˜?p ÀÓÓ [úz°…‹c‘€©¾qÜ¦:}MÁ›Ä‚òwÓ*»Á÷/[¡ô\‡—µ1òšı¬g»˜ºæç÷à/n•µ¢ò Á’á/Øı¥,ÓkK· ¡5X·wÑm.x¤‘×û×¼¾•ë÷=pD.„ù­:Ó¥×¦îêÏ{²X¡Rp…×ıêsÙ909 ¯*×]*8ëå¾áVFXŸ´ë5RbŠqCNµ=Ü?ç^4Bõ¡+âË/¿[ÃÑ*Ÿ««ŸòµÄO~²eìAÙ­‘u,¹îP-ËNê	Õ³èÛ-ß.ôH«{JË¹rÏãÛ9Ê7høÇõ?p4âXbT„²¬2™>ILÿöŞvGÆ"c•Âš¸5Uø| Ä«š˜o¥``ÑH<šRçëµ8•jG·!ÃÉş